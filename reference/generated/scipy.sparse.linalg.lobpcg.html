
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>scipy.sparse.linalg.lobpcg &#8212; SciPy v1.7.0.dev0+1036.4ec6f29 Manual</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/scipy.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="scipy.sparse.linalg.svds" href="scipy.sparse.linalg.svds.html" />
    <link rel="prev" title="scipy.sparse.linalg.eigsh" href="scipy.sparse.linalg.eigsh.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../index.html">
  <img src="../../_static/scipyshiny_small.png" class="logo" alt="logo">
</a>      


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../getting_started.html">
  Getting started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../tutorial/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="../index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../dev/index.html">
  Development
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../release.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/scipy/scipy" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../cluster.html">
   Clustering package (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.cluster
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../cluster.vq.html">
   K-means clustering and vector quantization (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.cluster.vq
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../cluster.hierarchy.html">
   Hierarchical clustering (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.cluster.hierarchy
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../constants.html">
   Constants (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.constants
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fft.html">
   Discrete Fourier transforms (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.fft
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fftpack.html">
   Legacy discrete Fourier transforms (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.fftpack
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../integrate.html">
   Integration and ODEs (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.integrate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../interpolate.html">
   Interpolation (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.interpolate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../io.html">
   Input and output (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.io
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.html">
   Linear algebra (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.linalg
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.blas.html">
   Low-level BLAS functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.linalg.blas
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.lapack.html">
   Low-level LAPACK functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.linalg.lapack
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.cython_blas.html">
   BLAS Functions for Cython
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.cython_lapack.html">
   LAPACK functions for Cython
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.interpolative.html">
   Interpolative matrix decomposition (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.linalg.interpolative
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../misc.html">
   Miscellaneous routines (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.misc
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ndimage.html">
   Multidimensional image processing (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.ndimage
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../odr.html">
   Orthogonal distance regression (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.odr
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../optimize.html">
   Optimization and root finding (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.optimize
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../optimize.nonlin.html">
   Nonlinear solvers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../optimize.cython_optimize.html">
   Cython optimize zeros API
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../signal.html">
   Signal processing (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.signal
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sparse.html">
   Sparse matrices (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.sparse
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="../sparse.linalg.html">
   Sparse linear algebra (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.sparse.linalg
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sparse.csgraph.html">
   Compressed sparse graph routines (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.sparse.csgraph
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../spatial.html">
   Spatial algorithms and data structures (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.spatial
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../spatial.distance.html">
   Distance computations (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.spatial.distance
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../special.html">
   Special functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.special
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../stats.html">
   Statistical functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.stats
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../stats._result_classes.html">
   Result classes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../stats.mstats.html">
   Statistical functions for masked arrays (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.stats.mstats
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../stats.qmc.html">
   Quasi-Monte Carlo submodule (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.stats.qmc
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ccallback.html">
   Low-level callback functions
  </a>
 </li>
</ul>

    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                

<nav id="bd-toc-nav">
    
</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="scipy-sparse-linalg-lobpcg">
<h1>scipy.sparse.linalg.lobpcg<a class="headerlink" href="#scipy-sparse-linalg-lobpcg" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="scipy.sparse.linalg.lobpcg">
<span class="sig-prename descclassname"><span class="pre">scipy.sparse.linalg.</span></span><span class="sig-name descname"><span class="pre">lobpcg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">largest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosityLevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retLambdaHistory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retResidualNormsHistory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scipy/scipy/blob/master/scipy/sparse/linalg/eigen/lobpcg/lobpcg.py#L127-L716"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scipy.sparse.linalg.lobpcg" title="Permalink to this definition">¶</a></dt>
<dd><p>Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)</p>
<p>LOBPCG is a preconditioned eigensolver for large symmetric positive
definite (SPD) generalized eigenproblems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">{sparse matrix, dense matrix, LinearOperator}</span></dt><dd><p>The symmetric linear operator of the problem, usually a
sparse matrix.  Often called the “stiffness matrix”.</p>
</dd>
<dt><strong>X</strong><span class="classifier">ndarray, float32 or float64</span></dt><dd><p>Initial approximation to the <code class="docutils literal notranslate"><span class="pre">k</span></code> eigenvectors (non-sparse). If <em class="xref py py-obj">A</em>
has <code class="docutils literal notranslate"><span class="pre">shape=(n,n)</span></code> then <em class="xref py py-obj">X</em> should have shape <code class="docutils literal notranslate"><span class="pre">shape=(n,k)</span></code>.</p>
</dd>
<dt><strong>B</strong><span class="classifier">{dense matrix, sparse matrix, LinearOperator}, optional</span></dt><dd><p>The right hand side operator in a generalized eigenproblem.
By default, <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">Identity</span></code>.  Often called the “mass matrix”.</p>
</dd>
<dt><strong>M</strong><span class="classifier">{dense matrix, sparse matrix, LinearOperator}, optional</span></dt><dd><p>Preconditioner to <em class="xref py py-obj">A</em>; by default <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">Identity</span></code>.
<em class="xref py py-obj">M</em> should approximate the inverse of <em class="xref py py-obj">A</em>.</p>
</dd>
<dt><strong>Y</strong><span class="classifier">ndarray, float32 or float64, optional</span></dt><dd><p>n-by-sizeY matrix of constraints (non-sparse), sizeY &lt; n
The iterations will be performed in the B-orthogonal complement
of the column-space of Y. Y must be full rank.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">scalar, optional</span></dt><dd><p>Solver tolerance (stopping criterion).
The default is <code class="docutils literal notranslate"><span class="pre">tol=n*sqrt(eps)</span></code>.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations.  The default is <code class="docutils literal notranslate"><span class="pre">maxiter</span> <span class="pre">=</span> <span class="pre">20</span></code>.</p>
</dd>
<dt><strong>largest</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, solve for the largest eigenvalues, otherwise the smallest.</p>
</dd>
<dt><strong>verbosityLevel</strong><span class="classifier">int, optional</span></dt><dd><p>Controls solver output.  The default is <code class="docutils literal notranslate"><span class="pre">verbosityLevel=0</span></code>.</p>
</dd>
<dt><strong>retLambdaHistory</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return eigenvalue history.  Default is False.</p>
</dd>
<dt><strong>retResidualNormsHistory</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return history of residual norms.  Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>Array of <code class="docutils literal notranslate"><span class="pre">k</span></code> eigenvalues</p>
</dd>
<dt><strong>v</strong><span class="classifier">ndarray</span></dt><dd><p>An array of <code class="docutils literal notranslate"><span class="pre">k</span></code> eigenvectors.  <em class="xref py py-obj">v</em> has the same shape as <em class="xref py py-obj">X</em>.</p>
</dd>
<dt><strong>lambdas</strong><span class="classifier">list of ndarray, optional</span></dt><dd><p>The eigenvalue history, if <em class="xref py py-obj">retLambdaHistory</em> is True.</p>
</dd>
<dt><strong>rnorms</strong><span class="classifier">list of ndarray, optional</span></dt><dd><p>The history of residual norms, if <em class="xref py py-obj">retResidualNormsHistory</em> is True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both <code class="docutils literal notranslate"><span class="pre">retLambdaHistory</span></code> and <code class="docutils literal notranslate"><span class="pre">retResidualNormsHistory</span></code> are True,
the return tuple has the following format
<code class="docutils literal notranslate"><span class="pre">(lambda,</span> <span class="pre">V,</span> <span class="pre">lambda</span> <span class="pre">history,</span> <span class="pre">residual</span> <span class="pre">norms</span> <span class="pre">history)</span></code>.</p>
<p>In the following <code class="docutils literal notranslate"><span class="pre">n</span></code> denotes the matrix size and <code class="docutils literal notranslate"><span class="pre">m</span></code> the number
of required eigenvalues (smallest or largest).</p>
<p>The LOBPCG code internally solves eigenproblems of the size <code class="docutils literal notranslate"><span class="pre">3m</span></code> on every
iteration by calling the “standard” dense eigensolver, so if <code class="docutils literal notranslate"><span class="pre">m</span></code> is not
small enough compared to <code class="docutils literal notranslate"><span class="pre">n</span></code>, it does not make sense to call the LOBPCG
code, but rather one should use the “standard” eigensolver, e.g. numpy or
scipy function in this case.
If one calls the LOBPCG algorithm for <code class="docutils literal notranslate"><span class="pre">5m</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>, it will most likely break
internally, so the code tries to call the standard function instead.</p>
<p>It is not that <code class="docutils literal notranslate"><span class="pre">n</span></code> should be large for the LOBPCG to work, but rather the
ratio <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">/</span> <span class="pre">m</span></code> should be large. It you call LOBPCG with <code class="docutils literal notranslate"><span class="pre">m=1</span></code>
and <code class="docutils literal notranslate"><span class="pre">n=10</span></code>, it works though <code class="docutils literal notranslate"><span class="pre">n</span></code> is small. The method is intended
for extremely large <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">/</span> <span class="pre">m</span></code> <a class="reference internal" href="#rbbbc6164e7a5-4" id="id1">[4]</a>.</p>
<p>The convergence speed depends basically on two factors:</p>
<ol class="arabic simple">
<li><p>How well relatively separated the seeking eigenvalues are from the rest
of the eigenvalues. One can try to vary <code class="docutils literal notranslate"><span class="pre">m</span></code> to make this better.</p></li>
<li><p>How well conditioned the problem is. This can be changed by using proper
preconditioning. For example, a rod vibration test problem (under tests
directory) is ill-conditioned for large <code class="docutils literal notranslate"><span class="pre">n</span></code>, so convergence will be
slow, unless efficient preconditioning is used. For this specific
problem, a good simple preconditioner function would be a linear solve
for <em class="xref py py-obj">A</em>, which is easy to code since A is tridiagonal.</p></li>
</ol>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbbbc6164e7a5-1"><span class="brackets">1</span></dt>
<dd><p>A. V. Knyazev (2001),
Toward the Optimal Preconditioned Eigensolver: Locally Optimal
Block Preconditioned Conjugate Gradient Method.
SIAM Journal on Scientific Computing 23, no. 2,
pp. 517-541. <a class="reference external" href="https://doi.org/10.1137/S1064827500366124">DOI:10.1137/S1064827500366124</a></p>
</dd>
<dt class="label" id="rbbbc6164e7a5-2"><span class="brackets">2</span></dt>
<dd><p>A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov
(2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers
(BLOPEX) in hypre and PETSc. <a class="reference external" href="https://arxiv.org/abs/0705.2626">arXiv:0705.2626</a></p>
</dd>
<dt class="label" id="rbbbc6164e7a5-3"><span class="brackets">3</span></dt>
<dd><p>A. V. Knyazev’s C and MATLAB implementations:
<a class="reference external" href="https://bitbucket.org/joseroman/blopex">https://bitbucket.org/joseroman/blopex</a></p>
</dd>
<dt class="label" id="rbbbc6164e7a5-4"><span class="brackets"><a class="fn-backref" href="#id1">4</a></span></dt>
<dd><p>S. Yamada, T. Imamura, T. Kano, and M. Machida (2006),
High-performance computing for exact numerical approaches to
quantum many-body problems on the earth simulator. In Proceedings
of the 2006 ACM/IEEE Conference on Supercomputing.
<a class="reference external" href="https://doi.org/10.1145/1188455.1188504">DOI:10.1145/1188455.1188504</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Solve <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">x</span></code> with constraints and preconditioning.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">spdiags</span><span class="p">,</span> <span class="n">issparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">lobpcg</span><span class="p">,</span> <span class="n">LinearOperator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[  1.,   0.,   0., ...,   0.,   0.,   0.],</span>
<span class="go">       [  0.,   2.,   0., ...,   0.,   0.,   0.],</span>
<span class="go">       [  0.,   0.,   3., ...,   0.,   0.,   0.],</span>
<span class="go">       ...,</span>
<span class="go">       [  0.,   0.,   0., ...,  98.,   0.,   0.],</span>
<span class="go">       [  0.,   0.,   0., ...,   0.,  99.,   0.],</span>
<span class="go">       [  0.,   0.,   0., ...,   0.,   0., 100.]])</span>
</pre></div>
</div>
<p>Constraints:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Initial guess for eigenvectors, should have linearly independent
columns. Column dimension = number of requested eigenvalues.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>Preconditioner in the inverse of A in this example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invA</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">([</span><span class="mf">1.</span><span class="o">/</span><span class="n">vals</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>The preconditiner must be defined by a function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">precond</span><span class="p">(</span> <span class="n">x</span> <span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">invA</span> <span class="o">@</span> <span class="n">x</span>
</pre></div>
</div>
<p>The argument x of the preconditioner function is a matrix inside <a class="reference internal" href="#scipy.sparse.linalg.lobpcg" title="scipy.sparse.linalg.lobpcg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lobpcg</span></code></a>,
thus the use of matrix-matrix product <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>.</p>
<p>The preconditioner function is passed to lobpcg as a <a class="reference internal" href="scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearOperator</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">LinearOperator</span><span class="p">(</span><span class="n">matvec</span><span class="o">=</span><span class="n">precond</span><span class="p">,</span> <span class="n">matmat</span><span class="o">=</span><span class="n">precond</span><span class="p">,</span>
<span class="gp">... </span>                   <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
</pre></div>
</div>
<p>Let us now solve the eigenvalue problem for the matrix A:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eigenvalues</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lobpcg</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigenvalues</span>
<span class="go">array([4., 5., 6.])</span>
</pre></div>
</div>
<p>Note that the vectors passed in Y are the eigenvectors of the 3 smallest
eigenvalues. The results returned are orthogonal to those.</p>
</dd></dl>

</section>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="scipy.sparse.linalg.eigsh.html" title="previous page">scipy.sparse.linalg.eigsh</a>
    <a class='right-next' id="next-link" href="scipy.sparse.linalg.svds.html" title="next page">scipy.sparse.linalg.svds</a>

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2008-2021, The SciPy community.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.2.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>