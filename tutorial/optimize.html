
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Optimization (scipy.optimize) &#8212; SciPy v1.15.0.dev Manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Vibur" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyterlite_sphinx.css?v=ca70e7f1" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/scipy.css?v=6dd54bfa" />
    <link rel="stylesheet" type="text/css" href="../_static/try_examples.css" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../_static/documentation_options.js?v=3d29109c"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=fe3c738c"></script>
    <script src="../_static/jupyterlite_sphinx.js?v=d6bdf5f8"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script data-domain="docs.scipy.org" defer="defer" src="https://views.scientific-python.org/js/script.js"></script>
    <script async="async" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'tutorial/optimize';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.0';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://scipy.github.io/devdocs/_static/version_switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = 'development';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = false;
        </script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Interpolation (scipy.interpolate)" href="interpolate.html" />
    <link rel="prev" title="Integration (scipy.integrate)" href="integrate.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="1.15.0.dev" />
    <meta name="docbuild:last-update" content="Oct 24, 2024"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.svg" class="logo__image only-light" alt=""/>
    <img src="../_static/logo.svg" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">SciPy</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-external" href="https://scipy.org/install/">
    Installing
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../reference/index.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../building/index.html">
    Building from source
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../dev/index.html">
    Development
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../release.html">
    Release notes
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scipy/scipy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/SciPy_team" title="Twitter" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Twitter</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-external" href="https://scipy.org/install/">
    Installing
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../reference/index.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../building/index.html">
    Building from source
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../dev/index.html">
    Development
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../release.html">
    Release notes
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scipy/scipy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/SciPy_team" title="Twitter" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Twitter</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links" aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav">
    <p aria-level="2" class="caption" role="heading"><span class="caption-text">User guide</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="special.html">Special functions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.special</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="integrate.html">Integration (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.integrate</span></code>)</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Optimization (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.optimize</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="interpolate.html">Interpolation (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.interpolate</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html">Fourier Transforms (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.fft</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="signal.html">Signal Processing (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="linalg.html">Linear Algebra (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="sparse.html">Sparse Arrays (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="arpack.html">Sparse eigenvalue problems with ARPACK</a></li>
<li class="toctree-l1"><a class="reference internal" href="csgraph.html">Compressed Sparse Graph Routines (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csgraph</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="spatial.html">Spatial data structures and algorithms (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.spatial</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="stats.html">Statistics (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ndimage.html">Multidimensional image processing (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">File IO (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.io</span></code>)</a></li>
</ul>

  </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">SciPy User Guide</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">Optimization (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.optimize</span></code>)</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="optimization-scipy-optimize">
<h1><a class="toc-backref" href="#id16" role="doc-backlink">Optimization (<a class="reference internal" href="../reference/optimize.html#module-scipy.optimize" title="scipy.optimize"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.optimize</span></code></a>)</a><a class="headerlink" href="#optimization-scipy-optimize" title="Link to this heading">#</a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#optimization-scipy-optimize" id="id16">Optimization (<a class="reference internal" href="../reference/optimize.html#module-scipy.optimize" title="scipy.optimize"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.optimize</span></code></a>)</a></p>
<ul>
<li><p><a class="reference internal" href="#local-minimization-of-multivariate-scalar-functions-minimize" id="id17">Local minimization of multivariate scalar functions (<a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a>)</a></p>
<ul>
<li><p><a class="reference internal" href="#unconstrained-minimization" id="id18">Unconstrained minimization</a></p>
<ul>
<li><p><a class="reference internal" href="#nelder-mead-simplex-algorithm-method-nelder-mead" id="id19">Nelder-Mead Simplex algorithm (<code class="docutils literal notranslate"><span class="pre">method='Nelder-Mead'</span></code>)</a></p></li>
<li><p><a class="reference internal" href="#broyden-fletcher-goldfarb-shanno-algorithm-method-bfgs" id="id20">Broyden-Fletcher-Goldfarb-Shanno algorithm (<code class="docutils literal notranslate"><span class="pre">method='BFGS'</span></code>)</a></p></li>
<li><p><a class="reference internal" href="#newton-conjugate-gradient-algorithm-method-newton-cg" id="id21">Newton-Conjugate-Gradient algorithm (<code class="docutils literal notranslate"><span class="pre">method='Newton-CG'</span></code>)</a></p></li>
<li><p><a class="reference internal" href="#trust-region-newton-conjugate-gradient-algorithm-method-trust-ncg" id="id22">Trust-Region Newton-Conjugate-Gradient Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-ncg'</span></code>)</a></p></li>
<li><p><a class="reference internal" href="#trust-region-truncated-generalized-lanczos-conjugate-gradient-algorithm-method-trust-krylov" id="id23">Trust-Region Truncated Generalized Lanczos / Conjugate Gradient Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-krylov'</span></code>)</a></p></li>
<li><p><a class="reference internal" href="#trust-region-nearly-exact-algorithm-method-trust-exact" id="id24">Trust-Region Nearly Exact Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-exact'</span></code>)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#constrained-minimization" id="id25">Constrained minimization</a></p>
<ul>
<li><p><a class="reference internal" href="#trust-region-constrained-algorithm-method-trust-constr" id="id26">Trust-Region Constrained Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-constr'</span></code>)</a></p></li>
<li><p><a class="reference internal" href="#sequential-least-squares-programming-slsqp-algorithm-method-slsqp" id="id27">Sequential Least SQuares Programming (SLSQP) Algorithm (<code class="docutils literal notranslate"><span class="pre">method='SLSQP'</span></code>)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#local-minimization-solver-comparison" id="id28">Local minimization solver comparison</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#global-optimization" id="id29">Global optimization</a></p>
<ul>
<li><p><a class="reference internal" href="#comparison-of-global-optimizers" id="id30">Comparison of Global Optimizers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#least-squares-minimization-least-squares" id="id31">Least-squares minimization (<a class="reference internal" href="../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-func docutils literal notranslate"><span class="pre">least_squares</span></code></a>)</a></p>
<ul>
<li><p><a class="reference internal" href="#example-of-solving-a-fitting-problem" id="id32">Example of solving a fitting problem</a></p></li>
<li><p><a class="reference internal" href="#further-examples" id="id33">Further examples</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#univariate-function-minimizers-minimize-scalar" id="id34">Univariate function minimizers (<a class="reference internal" href="../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize_scalar</span></code></a>)</a></p>
<ul>
<li><p><a class="reference internal" href="#unconstrained-minimization-method-brent" id="id35">Unconstrained minimization (<code class="docutils literal notranslate"><span class="pre">method='brent'</span></code>)</a></p></li>
<li><p><a class="reference internal" href="#bounded-minimization-method-bounded" id="id36">Bounded minimization (<code class="docutils literal notranslate"><span class="pre">method='bounded'</span></code>)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#custom-minimizers" id="id37">Custom minimizers</a></p></li>
<li><p><a class="reference internal" href="#root-finding" id="id38">Root finding</a></p>
<ul>
<li><p><a class="reference internal" href="#scalar-functions" id="id39">Scalar functions</a></p></li>
<li><p><a class="reference internal" href="#fixed-point-solving" id="id40">Fixed-point solving</a></p></li>
<li><p><a class="reference internal" href="#sets-of-equations" id="id41">Sets of equations</a></p></li>
<li><p><a class="reference internal" href="#root-finding-for-large-problems" id="id42">Root finding for large problems</a></p></li>
<li><p><a class="reference internal" href="#still-too-slow-preconditioning" id="id43">Still too slow? Preconditioning.</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#linear-programming-linprog" id="id44">Linear programming (<a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code></a>)</a></p>
<ul>
<li><p><a class="reference internal" href="#linear-programming-example" id="id45">Linear programming example</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#assignment-problems" id="id46">Assignment problems</a></p>
<ul>
<li><p><a class="reference internal" href="#linear-sum-assignment-problem-example" id="id47">Linear sum assignment problem example</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mixed-integer-linear-programming" id="id48">Mixed integer linear programming</a></p>
<ul>
<li><p><a class="reference internal" href="#knapsack-problem-example" id="id49">Knapsack problem example</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<p>The <a class="reference internal" href="../reference/optimize.html#module-scipy.optimize" title="scipy.optimize"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.optimize</span></code></a> package provides several commonly used
optimization algorithms. A detailed listing is available:
<a class="reference internal" href="../reference/optimize.html#module-scipy.optimize" title="scipy.optimize"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.optimize</span></code></a> (can also be found by <code class="docutils literal notranslate"><span class="pre">help(scipy.optimize)</span></code>).</p>
<section id="local-minimization-of-multivariate-scalar-functions-minimize">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">Local minimization of multivariate scalar functions (<a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a>)</a><a class="headerlink" href="#local-minimization-of-multivariate-scalar-functions-minimize" title="Link to this heading">#</a></h2>
<p>The <a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a> function provides a common interface to unconstrained
and constrained minimization algorithms for multivariate scalar functions
in <a class="reference internal" href="../reference/optimize.html#module-scipy.optimize" title="scipy.optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize</span></code></a>. To demonstrate the minimization function, consider the
problem of minimizing the Rosenbrock function of <span class="math notranslate nohighlight">\(N\)</span> variables:</p>
<div class="math notranslate nohighlight">
\[f\left(\mathbf{x}\right)=\sum_{i=1}^{N-1}100\left(x_{i+1}-x_{i}^{2}\right)^{2}+\left(1-x_{i}\right)^{2}.\]</div>
<p>The minimum value of this function is 0 which is achieved when
<span class="math notranslate nohighlight">\(x_{i}=1.\)</span></p>
<p>Note that the Rosenbrock function and its derivatives are included in
<a class="reference internal" href="../reference/optimize.html#module-scipy.optimize" title="scipy.optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize</span></code></a>. The implementations shown in the following sections
provide examples of how to define an objective function as well as its
jacobian and hessian functions. Objective functions in <a class="reference internal" href="../reference/optimize.html#module-scipy.optimize" title="scipy.optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize</span></code></a>
expect a numpy array as their first parameter which is to be optimized
and must return a float value. The exact calling signature must be
<code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">*args)</span></code> where <code class="docutils literal notranslate"><span class="pre">x</span></code> represents a numpy array and <code class="docutils literal notranslate"><span class="pre">args</span></code>
a tuple of additional arguments supplied to the objective function.</p>
<section id="unconstrained-minimization">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Unconstrained minimization</a><a class="headerlink" href="#unconstrained-minimization" title="Link to this heading">#</a></h3>
<section id="nelder-mead-simplex-algorithm-method-nelder-mead">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">Nelder-Mead Simplex algorithm (<code class="docutils literal notranslate"><span class="pre">method='Nelder-Mead'</span></code>)</a><a class="headerlink" href="#nelder-mead-simplex-algorithm-method-nelder-mead" title="Link to this heading">#</a></h4>
<p>In the example below, the <a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a> routine is used
with the <em>Nelder-Mead</em> simplex algorithm (selected through the <code class="docutils literal notranslate"><span class="pre">method</span></code>
parameter):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span><span class="w">    </span><span class="sd">&quot;&quot;&quot;The Rosenbrock function&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mf">100.0</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nelder-mead&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xatol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 339</span>
<span class="go">         Function evaluations: 571</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[1. 1. 1. 1. 1.]</span>
</pre></div>
</div>
<p>The simplex algorithm is probably the simplest way to minimize a fairly
well-behaved function. It requires only function evaluations and is a good
choice for simple minimization problems. However, because it does not use
any gradient evaluations, it may take longer to find the minimum.</p>
<p>Another optimization algorithm that needs only function calls to find
the minimum is <em>Powell</em>’s method available by setting <code class="docutils literal notranslate"><span class="pre">method='powell'</span></code> in
<a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a>.</p>
<p>To demonstrate how to supply additional arguments to an objective function,
let us minimize the Rosenbrock function with an additional scaling factor <em class="xref py py-obj">a</em>
and an offset <em class="xref py py-obj">b</em>:</p>
<div class="math notranslate nohighlight">
\[f\left(\mathbf{x}, a, b\right)=\sum_{i=1}^{N-1}a\left(x_{i+1}-x_{i}^{2}\right)^{2}+\left(1-x_{i}\right)^{2} + b.\]</div>
<p>Again using the <a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a> routine this can be solved by the following
code block for the example parameters <code class="docutils literal notranslate"><span class="pre">a=0.5</span></code> and <code class="docutils literal notranslate"><span class="pre">b=1</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen_with_args</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span><span class="w">    </span><span class="sd">&quot;&quot;&quot;The Rosenbrock function with additional arguments&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen_with_args</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nelder-mead&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xatol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 1.000000</span>
<span class="go">         Iterations: 319 # may vary</span>
<span class="go">         Function evaluations: 525 # may vary</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[1.         1.         1.         1.         0.99999999]</span>
</pre></div>
</div>
<p>As an alternative to using the <code class="docutils literal notranslate"><span class="pre">args</span></code> parameter of <a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a>, simply
wrap the objective function in a new function that accepts only <code class="docutils literal notranslate"><span class="pre">x</span></code>. This
approach is also useful when it is necessary to pass additional parameters to
the objective function as keyword arguments.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen_with_args</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>  <span class="c1"># b is a keyword-only argument</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">wrapped_rosen_without_args</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">rosen_with_args</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>  <span class="c1"># pass in `a` and `b`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">wrapped_rosen_without_args</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nelder-mead&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xatol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[1.         1.         1.         1.         0.99999999]</span>
</pre></div>
</div>
<p>Another alternative is to use <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">partial_rosen</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">rosen_with_args</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">partial_rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nelder-mead&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xatol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[1.         1.         1.         1.         0.99999999]</span>
</pre></div>
</div>
</section>
<section id="broyden-fletcher-goldfarb-shanno-algorithm-method-bfgs">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">Broyden-Fletcher-Goldfarb-Shanno algorithm (<code class="docutils literal notranslate"><span class="pre">method='BFGS'</span></code>)</a><a class="headerlink" href="#broyden-fletcher-goldfarb-shanno-algorithm-method-bfgs" title="Link to this heading">#</a></h4>
<p>In order to converge more quickly to the solution, this routine uses
the gradient of the objective function. If the gradient is not given
by the user, then it is estimated using first-differences. The
Broyden-Fletcher-Goldfarb-Shanno (BFGS) method typically requires
fewer function calls than the simplex algorithm even when the gradient
must be estimated.</p>
<p>To demonstrate this algorithm, the Rosenbrock function is again used.
The gradient of the Rosenbrock function is the vector:</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \frac{\partial f}{\partial x_{j}} &amp; = &amp; \sum_{i=1}^{N}200\left(x_{i}-x_{i-1}^{2}\right)\left(\delta_{i,j}-2x_{i-1}\delta_{i-1,j}\right)-2\left(1-x_{i-1}\right)\delta_{i-1,j}.\\  &amp; = &amp; 200\left(x_{j}-x_{j-1}^{2}\right)-400x_{j}\left(x_{j+1}-x_{j}^{2}\right)-2\left(1-x_{j}\right).\end{eqnarray*}</div><p>This expression is valid for the interior derivatives. Special cases
are</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \frac{\partial f}{\partial x_{0}} &amp; = &amp; -400x_{0}\left(x_{1}-x_{0}^{2}\right)-2\left(1-x_{0}\right),\\ \frac{\partial f}{\partial x_{N-1}} &amp; = &amp; 200\left(x_{N-1}-x_{N-2}^{2}\right).\end{eqnarray*}</div><p>A Python function which computes this gradient is constructed by the
code-segment:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen_der</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xm</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">xm_m1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">xm_p1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="n">der</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">der</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="o">*</span><span class="p">(</span><span class="n">xm</span><span class="o">-</span><span class="n">xm_m1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">400</span><span class="o">*</span><span class="p">(</span><span class="n">xm_p1</span> <span class="o">-</span> <span class="n">xm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">xm</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">xm</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">der</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="n">der</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">der</span>
</pre></div>
</div>
<p>This gradient information is specified in the <a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a> function
through the <code class="docutils literal notranslate"><span class="pre">jac</span></code> parameter as illustrated below.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;BFGS&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 25                     # may vary</span>
<span class="go">         Function evaluations: 30</span>
<span class="go">         Gradient evaluations: 30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
<p><strong>Avoiding Redundant Calculation</strong></p>
<p>It is common for the objective function and its gradient to share parts of the
calculation. For instance, consider the following problem.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="o">-</span><span class="n">expensive</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">expensive</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">dexpensive</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">expensive</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># this function is computationally expensive!</span>
<span class="gp">... </span>    <span class="n">expensive</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># let&#39;s keep track of how many times it runs</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expensive</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dexpensive</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">fun</span>
<span class="go">-0.9999999999999174</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">nfev</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">njev</span>
<span class="go">6, 6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expensive</span><span class="o">.</span><span class="n">count</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">expensive</span></code> is called 12 times: six times in the objective function and
six times from the gradient. One way of reducing redundant calculations is to
create a single function that returns both the objective function and the
gradient.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f_and_df</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">expensive_value</span> <span class="o">=</span> <span class="n">expensive</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">expensive_value</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># objective function</span>
<span class="gp">... </span>            <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">expensive_value</span><span class="o">*</span><span class="n">dexpensive</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>  <span class="c1"># gradient</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expensive</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># reset the counter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">f_and_df</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">fun</span>
<span class="go">-0.9999999999999174</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expensive</span><span class="o">.</span><span class="n">count</span>
<span class="go">6</span>
</pre></div>
</div>
<p>When we call minimize, we specify <code class="docutils literal notranslate"><span class="pre">jac==True</span></code> to indicate that the provided
function returns both the objective function and its gradient. While
convenient, not all <a class="reference internal" href="../reference/optimize.html#module-scipy.optimize" title="scipy.optimize"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.optimize</span></code></a> functions support this feature,
and moreover, it is only for sharing calculations between the function and its
gradient, whereas in some problems we will want to share calculations with the
Hessian (second derivative of the objective function) and constraints. A more
general approach is to memoize the expensive parts of the calculation. In
simple situations, this can be accomplished with the
<a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.lru_cache" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.lru_cache</span></code></a> wrapper.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expensive</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># reset the counter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expensive</span> <span class="o">=</span> <span class="n">lru_cache</span><span class="p">(</span><span class="n">expensive</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">fun</span>
<span class="go">-0.9999999999999174</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expensive</span><span class="o">.</span><span class="n">count</span>
<span class="go">6</span>
</pre></div>
</div>
</section>
<section id="newton-conjugate-gradient-algorithm-method-newton-cg">
<h4><a class="toc-backref" href="#id21" role="doc-backlink">Newton-Conjugate-Gradient algorithm (<code class="docutils literal notranslate"><span class="pre">method='Newton-CG'</span></code>)</a><a class="headerlink" href="#newton-conjugate-gradient-algorithm-method-newton-cg" title="Link to this heading">#</a></h4>
<p>Newton-Conjugate Gradient algorithm is a modified Newton’s
method and uses a conjugate gradient algorithm to (approximately) invert
the local Hessian <a class="reference internal" href="#nw" id="id1"><span>[NW]</span></a>.  Newton’s method is based on fitting the function
locally to a quadratic form:</p>
<div class="math notranslate nohighlight">
\[f\left(\mathbf{x}\right)\approx f\left(\mathbf{x}_{0}\right)+\nabla f\left(\mathbf{x}_{0}\right)\cdot\left(\mathbf{x}-\mathbf{x}_{0}\right)+\frac{1}{2}\left(\mathbf{x}-\mathbf{x}_{0}\right)^{T}\mathbf{H}\left(\mathbf{x}_{0}\right)\left(\mathbf{x}-\mathbf{x}_{0}\right).\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{H}\left(\mathbf{x}_{0}\right)\)</span> is a matrix of second-derivatives (the Hessian). If the Hessian is
positive definite then the local minimum of this function can be found
by setting the gradient of the quadratic form to zero, resulting in</p>
<div class="math notranslate nohighlight">
\[\mathbf{x}_{\textrm{opt}}=\mathbf{x}_{0}-\mathbf{H}^{-1}\nabla f.\]</div>
<p>The inverse of the Hessian is evaluated using the conjugate-gradient
method. An example of employing this method to minimizing the
Rosenbrock function is given below. To take full advantage of the
Newton-CG method, a function which computes the Hessian must be
provided. The Hessian matrix itself does not need to be constructed,
only a vector which is the product of the Hessian with an arbitrary
vector needs to be available to the minimization routine. As a result,
the user can provide either a function to compute the Hessian matrix,
or a function to compute the product of the Hessian with an arbitrary
vector.</p>
<p><strong>Full Hessian example</strong></p>
<p>The Hessian of the Rosenbrock function is</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} H_{ij}=\frac{\partial^{2}f}{\partial x_{i}\partial x_{j}} &amp; = &amp; 200\left(\delta_{i,j}-2x_{i-1}\delta_{i-1,j}\right)-400x_{i}\left(\delta_{i+1,j}-2x_{i}\delta_{i,j}\right)-400\delta_{i,j}\left(x_{i+1}-x_{i}^{2}\right)+2\delta_{i,j},\\  &amp; = &amp; \left(202+1200x_{i}^{2}-400x_{i+1}\right)\delta_{i,j}-400x_{i}\delta_{i+1,j}-400x_{i-1}\delta_{i-1,j},\end{eqnarray*}</div><p>if <span class="math notranslate nohighlight">\(i,j\in\left[1,N-2\right]\)</span> with <span class="math notranslate nohighlight">\(i,j\in\left[0,N-1\right]\)</span> defining the <span class="math notranslate nohighlight">\(N\times N\)</span> matrix. Other non-zero entries of the matrix are</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \frac{\partial^{2}f}{\partial x_{0}^{2}} &amp; = &amp; 1200x_{0}^{2}-400x_{1}+2,\\ \frac{\partial^{2}f}{\partial x_{0}\partial x_{1}}=\frac{\partial^{2}f}{\partial x_{1}\partial x_{0}} &amp; = &amp; -400x_{0},\\ \frac{\partial^{2}f}{\partial x_{N-1}\partial x_{N-2}}=\frac{\partial^{2}f}{\partial x_{N-2}\partial x_{N-1}} &amp; = &amp; -400x_{N-2},\\ \frac{\partial^{2}f}{\partial x_{N-1}^{2}} &amp; = &amp; 200.\end{eqnarray*}</div><p>For example, the Hessian when <span class="math notranslate nohighlight">\(N=5\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{H}=\begin{bmatrix} 1200x_{0}^{2}+2\mkern-2em\\&amp;1200x_{1}^{2}+202\mkern-2em\\&amp;&amp;1200x_{1}^{2}+202\mkern-2em\\&amp;&amp;&amp;1200x_{3}^{2}+202\mkern-1em\\&amp;&amp;&amp;&amp;200\end{bmatrix}-400\begin{bmatrix} x_1 &amp; x_0 \\ x_0 &amp; x_2 &amp; x_1 \\ &amp; x_1 &amp; x_3 &amp; x_2\\ &amp; &amp; x_2 &amp; x_4 &amp; x_3 \\ &amp; &amp; &amp; x_3 &amp; 0\end{bmatrix}.\end{split}\]</div>
<p>The code which computes this Hessian along with the code to minimize
the function using Newton-CG method is shown in the following example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen_hess</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">diagonal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1200</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span>
<span class="gp">... </span>    <span class="n">diagonal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span>
<span class="gp">... </span>    <span class="n">diagonal</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">202</span> <span class="o">+</span> <span class="mi">1200</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diagonal</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">H</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Newton-CG&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">rosen_hess</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 19                       # may vary</span>
<span class="go">         Function evaluations: 22</span>
<span class="go">         Gradient evaluations: 19</span>
<span class="go">         Hessian evaluations: 19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1.,  1.,  1.,  1.,  1.])</span>
</pre></div>
</div>
<p><strong>Hessian product example</strong></p>
<p>For larger minimization problems, storing the entire Hessian matrix can
consume considerable time and memory. The Newton-CG algorithm only needs
the product of the Hessian times an arbitrary vector. As a result, the user
can supply code to compute this product rather than the full Hessian by
giving a <code class="docutils literal notranslate"><span class="pre">hess</span></code> function which take the minimization vector as the first
argument and the arbitrary vector as the second argument (along with extra
arguments passed to the function to be minimized). If possible, using
Newton-CG with the Hessian product option is probably the fastest way to
minimize the function.</p>
<p>In this case, the product of the Rosenbrock Hessian with an arbitrary
vector is not difficult to compute. If <span class="math notranslate nohighlight">\(\mathbf{p}\)</span> is the arbitrary
vector, then <span class="math notranslate nohighlight">\(\mathbf{H}\left(\mathbf{x}\right)\mathbf{p}\)</span> has
elements:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{H}\left(\mathbf{x}\right)\mathbf{p}=\begin{bmatrix} \left(1200x_{0}^{2}-400x_{1}+2\right)p_{0}-400x_{0}p_{1}\\ \vdots\\ -400x_{i-1}p_{i-1}+\left(202+1200x_{i}^{2}-400x_{i+1}\right)p_{i}-400x_{i}p_{i+1}\\ \vdots\\ -400x_{N-2}p_{N-2}+200p_{N-1}\end{bmatrix}.\end{split}\]</div>
<p>Code which makes use of this Hessian product to minimize the
Rosenbrock function using <a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a> follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen_hess_p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">Hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">Hp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1200</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">Hp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">202</span><span class="o">+</span><span class="mi">1200</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> \
<span class="gp">... </span>               <span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="n">Hp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">400</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">200</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">Hp</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Newton-CG&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hessp</span><span class="o">=</span><span class="n">rosen_hess_p</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 20                    # may vary</span>
<span class="go">         Function evaluations: 23</span>
<span class="go">         Gradient evaluations: 20</span>
<span class="go">         Hessian evaluations: 44</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
<p>According to <a class="reference internal" href="#nw" id="id2"><span>[NW]</span></a> p. 170 the <code class="docutils literal notranslate"><span class="pre">Newton-CG</span></code> algorithm can be inefficient
when the Hessian is ill-conditioned because of the poor quality search directions
provided by the method in those situations. The method <code class="docutils literal notranslate"><span class="pre">trust-ncg</span></code>,
according to the authors, deals more effectively with this problematic situation
and will be described next.</p>
</section>
<section id="trust-region-newton-conjugate-gradient-algorithm-method-trust-ncg">
<h4><a class="toc-backref" href="#id22" role="doc-backlink">Trust-Region Newton-Conjugate-Gradient Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-ncg'</span></code>)</a><a class="headerlink" href="#trust-region-newton-conjugate-gradient-algorithm-method-trust-ncg" title="Link to this heading">#</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">Newton-CG</span></code> method is a line search method: it finds a direction
of search minimizing a quadratic approximation of the function and then uses
a line search algorithm to find the (nearly) optimal step size in that direction.
An alternative approach is to, first, fix the step size limit <span class="math notranslate nohighlight">\(\Delta\)</span> and then find the
optimal step <span class="math notranslate nohighlight">\(\mathbf{p}\)</span> inside the given trust-radius by solving
the following quadratic subproblem:</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
   \min_{\mathbf{p}} f\left(\mathbf{x}_{k}\right)+\nabla f\left(\mathbf{x}_{k}\right)\cdot\mathbf{p}+\frac{1}{2}\mathbf{p}^{T}\mathbf{H}\left(\mathbf{x}_{k}\right)\mathbf{p};&amp;\\
   \text{subject to: } \|\mathbf{p}\|\le \Delta.&amp;
 \end{eqnarray*}</div><p>The solution is then updated <span class="math notranslate nohighlight">\(\mathbf{x}_{k+1} = \mathbf{x}_{k} + \mathbf{p}\)</span> and
the trust-radius <span class="math notranslate nohighlight">\(\Delta\)</span> is adjusted according to the degree of agreement of the quadratic
model with the real function. This family of methods is known as trust-region methods.
The <code class="docutils literal notranslate"><span class="pre">trust-ncg</span></code> algorithm is a trust-region method that uses a conjugate gradient algorithm
to solve the trust-region subproblem <a class="reference internal" href="#nw" id="id3"><span>[NW]</span></a>.</p>
<p><strong>Full Hessian example</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-ncg&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">rosen_hess</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 20                    # may vary</span>
<span class="go">         Function evaluations: 21</span>
<span class="go">         Gradient evaluations: 20</span>
<span class="go">         Hessian evaluations: 19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
<p><strong>Hessian product example</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-ncg&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hessp</span><span class="o">=</span><span class="n">rosen_hess_p</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 20                    # may vary</span>
<span class="go">         Function evaluations: 21</span>
<span class="go">         Gradient evaluations: 20</span>
<span class="go">         Hessian evaluations: 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
</section>
<section id="trust-region-truncated-generalized-lanczos-conjugate-gradient-algorithm-method-trust-krylov">
<h4><a class="toc-backref" href="#id23" role="doc-backlink">Trust-Region Truncated Generalized Lanczos / Conjugate Gradient Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-krylov'</span></code>)</a><a class="headerlink" href="#trust-region-truncated-generalized-lanczos-conjugate-gradient-algorithm-method-trust-krylov" title="Link to this heading">#</a></h4>
<p>Similar to the <code class="docutils literal notranslate"><span class="pre">trust-ncg</span></code> method, the <code class="docutils literal notranslate"><span class="pre">trust-krylov</span></code> method is a method
suitable for large-scale problems as it uses the hessian only as linear
operator by means of matrix-vector products.
It solves the quadratic subproblem more accurately than the <code class="docutils literal notranslate"><span class="pre">trust-ncg</span></code>
method.</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
   \min_{\mathbf{p}} f\left(\mathbf{x}_{k}\right)+\nabla f\left(\mathbf{x}_{k}\right)\cdot\mathbf{p}+\frac{1}{2}\mathbf{p}^{T}\mathbf{H}\left(\mathbf{x}_{k}\right)\mathbf{p};&amp;\\
   \text{subject to: } \|\mathbf{p}\|\le \Delta.&amp;
 \end{eqnarray*}</div><p>This method wraps the <a class="reference internal" href="#trlib" id="id4"><span>[TRLIB]</span></a> implementation of the <a class="reference internal" href="#gltr" id="id5"><span>[GLTR]</span></a> method solving
exactly a trust-region subproblem restricted to a truncated Krylov subspace.
For indefinite problems it is usually better to use this method as it reduces
the number of nonlinear iterations at the expense of few more matrix-vector
products per subproblem solve in comparison to the <code class="docutils literal notranslate"><span class="pre">trust-ncg</span></code> method.</p>
<p><strong>Full Hessian example</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-krylov&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">rosen_hess</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 19                    # may vary</span>
<span class="go">         Function evaluations: 20</span>
<span class="go">         Gradient evaluations: 20</span>
<span class="go">         Hessian evaluations: 18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
<p><strong>Hessian product example</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-krylov&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hessp</span><span class="o">=</span><span class="n">rosen_hess_p</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 19                    # may vary</span>
<span class="go">         Function evaluations: 20</span>
<span class="go">         Gradient evaluations: 20</span>
<span class="go">         Hessian evaluations: 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
<div role="list" class="citation-list">
<div class="citation" id="trlib" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">TRLIB</a><span class="fn-bracket">]</span></span>
<p>F. Lenders, C. Kirches, A. Potschka: “trlib: A vector-free
implementation of the GLTR method for iterative solution of
the trust region problem”, <a class="reference external" href="https://arxiv.org/abs/1611.04718">arXiv:1611.04718</a></p>
</div>
<div class="citation" id="gltr" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">GLTR</a><span class="fn-bracket">]</span></span>
<p>N. Gould, S. Lucidi, M. Roma, P. Toint: “Solving the
Trust-Region Subproblem using the Lanczos Method”,
SIAM J. Optim., 9(2), 504–525, (1999).
<a class="reference external" href="https://doi.org/10.1137/S1052623497322735">DOI:10.1137/S1052623497322735</a></p>
</div>
</div>
</section>
<section id="trust-region-nearly-exact-algorithm-method-trust-exact">
<h4><a class="toc-backref" href="#id24" role="doc-backlink">Trust-Region Nearly Exact Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-exact'</span></code>)</a><a class="headerlink" href="#trust-region-nearly-exact-algorithm-method-trust-exact" title="Link to this heading">#</a></h4>
<p>All methods <code class="docutils literal notranslate"><span class="pre">Newton-CG</span></code>, <code class="docutils literal notranslate"><span class="pre">trust-ncg</span></code> and <code class="docutils literal notranslate"><span class="pre">trust-krylov</span></code> are suitable for dealing with
large-scale problems (problems with thousands of variables). That is because the conjugate
gradient algorithm approximately solve the trust-region subproblem (or invert the Hessian)
by iterations without the explicit Hessian factorization. Since only the product of the Hessian
with an arbitrary vector is needed, the algorithm is specially suited for dealing
with sparse Hessians, allowing low storage requirements and significant time savings for
those sparse problems.</p>
<p>For medium-size problems, for which the storage and factorization cost of the Hessian are not critical,
it is possible to obtain a solution within fewer iteration by solving the trust-region subproblems
almost exactly. To achieve that, a certain nonlinear equations is solved iteratively for each quadratic
subproblem <a class="reference internal" href="#cgt" id="id6"><span>[CGT]</span></a>. This solution requires usually 3 or 4 Cholesky factorizations of the
Hessian matrix. As the result, the method converges in fewer number of iterations
and takes fewer evaluations of the objective function than the other implemented
trust-region methods. The Hessian product option is not supported by this algorithm. An
example using the Rosenbrock function follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-exact&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">rosen_hess</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">Optimization terminated successfully.</span>
<span class="go">         Current function value: 0.000000</span>
<span class="go">         Iterations: 13                    # may vary</span>
<span class="go">         Function evaluations: 14</span>
<span class="go">         Gradient evaluations: 13</span>
<span class="go">         Hessian evaluations: 14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
<div role="list" class="citation-list">
<div class="citation" id="nw" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>NW<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>,<a role="doc-backlink" href="#id3">3</a>)</span>
<p>J. Nocedal, S.J. Wright “Numerical optimization.”
2nd edition. Springer Science (2006).</p>
</div>
<div class="citation" id="cgt" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">CGT</a><span class="fn-bracket">]</span></span>
<p>Conn, A. R., Gould, N. I., &amp; Toint, P. L.
“Trust region methods”. Siam. (2000). pp. 169-200.</p>
</div>
</div>
</section>
</section>
<section id="constrained-minimization">
<span id="tutorial-sqlsp"></span><h3><a class="toc-backref" href="#id25" role="doc-backlink">Constrained minimization</a><a class="headerlink" href="#constrained-minimization" title="Link to this heading">#</a></h3>
<p>The <a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a> function provides several algorithms for constrained minimization,
namely <code class="docutils literal notranslate"><span class="pre">'trust-constr'</span></code> ,  <code class="docutils literal notranslate"><span class="pre">'SLSQP'</span></code>, <code class="docutils literal notranslate"><span class="pre">'COBYLA'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'COBYQA'</span></code>. They require the constraints
to be defined using slightly different structures. The methods <code class="docutils literal notranslate"><span class="pre">'trust-constr'</span></code> and <code class="docutils literal notranslate"><span class="pre">'COBYQA'</span></code> require
the  constraints to be defined as a sequence of objects <a class="reference internal" href="../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint" title="scipy.optimize.LinearConstraint"><code class="xref py py-func docutils literal notranslate"><span class="pre">LinearConstraint</span></code></a> and
<a class="reference internal" href="../reference/generated/scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint" title="scipy.optimize.NonlinearConstraint"><code class="xref py py-func docutils literal notranslate"><span class="pre">NonlinearConstraint</span></code></a>. Methods <code class="docutils literal notranslate"><span class="pre">'SLSQP'</span></code> and <code class="docutils literal notranslate"><span class="pre">'COBYLA'</span></code>, on the other hand,
require constraints to be defined as a sequence of dictionaries, with keys
<code class="docutils literal notranslate"><span class="pre">type</span></code>, <code class="docutils literal notranslate"><span class="pre">fun</span></code> and <code class="docutils literal notranslate"><span class="pre">jac</span></code>.</p>
<p>As an example let us consider the constrained minimization of the Rosenbrock function:</p>
<div class="math notranslate nohighlight">
  \begin{eqnarray*} \min_{x_0, x_1} &amp; ~~100\left(x_{1}-x_{0}^{2}\right)^{2}+\left(1-x_{0}\right)^{2} &amp;\\
                  \text{subject to: } &amp; x_0 + 2 x_1 \leq 1 &amp; \\
                                      &amp; x_0^2 + x_1 \leq 1  &amp; \\
                                      &amp; x_0^2 - x_1 \leq 1  &amp; \\
                                      &amp; 2 x_0 + x_1 = 1 &amp; \\
                                      &amp; 0 \leq  x_0  \leq 1 &amp; \\
                                      &amp; -0.5 \leq  x_1  \leq 2.0. &amp; \end{eqnarray*}</div><p>This optimization problem has the unique solution <span class="math notranslate nohighlight">\([x_0, x_1] = [0.4149,~ 0.1701]\)</span>,
for which only the first and fourth constraints are active.</p>
<section id="trust-region-constrained-algorithm-method-trust-constr">
<h4><a class="toc-backref" href="#id26" role="doc-backlink">Trust-Region Constrained Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-constr'</span></code>)</a><a class="headerlink" href="#trust-region-constrained-algorithm-method-trust-constr" title="Link to this heading">#</a></h4>
<p>The trust-region constrained method deals with constrained minimization problems of the form:</p>
<div class="math notranslate nohighlight">
  \begin{eqnarray*} \min_x &amp; f(x) &amp; \\
       \text{subject to: } &amp; ~~~ c^l  \leq c(x) \leq c^u, &amp;\\
        &amp;  x^l  \leq x \leq x^u. &amp; \end{eqnarray*}</div><p>When <span class="math notranslate nohighlight">\(c^l_j = c^u_j\)</span> the method reads the <span class="math notranslate nohighlight">\(j\)</span>-th constraint as an
equality constraint and deals with it accordingly. Besides that, one-sided constraint
can be specified by setting the upper or lower bound to <code class="docutils literal notranslate"><span class="pre">np.inf</span></code> with the appropriate sign.</p>
<p>The implementation is based on <a class="reference internal" href="#eqsqp" id="id7"><span>[EQSQP]</span></a> for equality-constraint problems and on <a class="reference internal" href="#trip" id="id8"><span>[TRIP]</span></a>
for problems with inequality constraints. Both are trust-region type algorithms suitable
for large-scale problems.</p>
<p><strong>Defining Bounds Constraints</strong></p>
<p>The bound constraints  <span class="math notranslate nohighlight">\(0 \leq  x_0  \leq 1\)</span> and <span class="math notranslate nohighlight">\(-0.5 \leq  x_1  \leq 2.0\)</span>
are defined using a <a class="reference internal" href="../reference/generated/scipy.optimize.Bounds.html#scipy.optimize.Bounds" title="scipy.optimize.Bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">Bounds</span></code></a> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">Bounds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">Bounds</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Defining Linear Constraints</strong></p>
<p>The constraints <span class="math notranslate nohighlight">\(x_0 + 2 x_1 \leq 1\)</span>
and <span class="math notranslate nohighlight">\(2 x_0 + x_1 = 1\)</span> can be written in the linear constraint standard format:</p>
<div class="math notranslate nohighlight">
  \begin{equation*} \begin{bmatrix}-\infty \\1\end{bmatrix} \leq
   \begin{bmatrix} 1&amp; 2 \\ 2&amp; 1\end{bmatrix}
    \begin{bmatrix} x_0 \\x_1\end{bmatrix} \leq
     \begin{bmatrix} 1 \\ 1\end{bmatrix},\end{equation*}</div><p>and defined using a <a class="reference internal" href="../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint" title="scipy.optimize.LinearConstraint"><code class="xref py py-func docutils literal notranslate"><span class="pre">LinearConstraint</span></code></a> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">LinearConstraint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_constraint</span> <span class="o">=</span> <span class="n">LinearConstraint</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Defining Nonlinear Constraints</strong>
The nonlinear constraint:</p>
<div class="math notranslate nohighlight">
  \begin{equation*} c(x) =
  \begin{bmatrix} x_0^2 + x_1 \\ x_0^2 - x_1\end{bmatrix}
   \leq
   \begin{bmatrix} 1 \\ 1\end{bmatrix}, \end{equation*}</div><p>with Jacobian matrix:</p>
<div class="math notranslate nohighlight">
  \begin{equation*} J(x) =
  \begin{bmatrix} 2x_0 &amp; 1 \\ 2x_0 &amp; -1\end{bmatrix},\end{equation*}</div><p>and linear combination of the Hessians:</p>
<div class="math notranslate nohighlight">
  \begin{equation*} H(x, v) = \sum_{i=0}^1 v_i \nabla^2 c_i(x) =
  v_0\begin{bmatrix} 2 &amp; 0 \\ 0 &amp; 0\end{bmatrix} +
  v_1\begin{bmatrix} 2 &amp; 0 \\ 0 &amp; 0\end{bmatrix},
  \end{equation*}</div><p>is defined using a <a class="reference internal" href="../reference/generated/scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint" title="scipy.optimize.NonlinearConstraint"><code class="xref py py-func docutils literal notranslate"><span class="pre">NonlinearConstraint</span></code></a> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cons_f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cons_J</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">[[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cons_H</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">NonlinearConstraint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinear_constraint</span> <span class="o">=</span> <span class="n">NonlinearConstraint</span><span class="p">(</span><span class="n">cons_f</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">cons_J</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">cons_H</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, it is also possible to define the Hessian <span class="math notranslate nohighlight">\(H(x, v)\)</span>
as a sparse matrix,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csc_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cons_H_sparse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">csc_matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">csc_matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinear_constraint</span> <span class="o">=</span> <span class="n">NonlinearConstraint</span><span class="p">(</span><span class="n">cons_f</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">jac</span><span class="o">=</span><span class="n">cons_J</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">cons_H_sparse</span><span class="p">)</span>
</pre></div>
</div>
<p>or as a <a class="reference internal" href="../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearOperator</span></code></a> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">LinearOperator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cons_H_linear_operator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">matvec</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">LinearOperator</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">matvec</span><span class="o">=</span><span class="n">matvec</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinear_constraint</span> <span class="o">=</span> <span class="n">NonlinearConstraint</span><span class="p">(</span><span class="n">cons_f</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                                          <span class="n">jac</span><span class="o">=</span><span class="n">cons_J</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">cons_H_linear_operator</span><span class="p">)</span>
</pre></div>
</div>
<p>When the evaluation of the Hessian <span class="math notranslate nohighlight">\(H(x, v)\)</span>
is difficult to implement or computationally infeasible, one may use <a class="reference internal" href="../reference/generated/scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy" title="scipy.optimize.HessianUpdateStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">HessianUpdateStrategy</span></code></a>.
Currently available strategies are <a class="reference internal" href="../reference/generated/scipy.optimize.BFGS.html#scipy.optimize.BFGS" title="scipy.optimize.BFGS"><code class="xref py py-class docutils literal notranslate"><span class="pre">BFGS</span></code></a> and <a class="reference internal" href="../reference/generated/scipy.optimize.SR1.html#scipy.optimize.SR1" title="scipy.optimize.SR1"><code class="xref py py-class docutils literal notranslate"><span class="pre">SR1</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">BFGS</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinear_constraint</span> <span class="o">=</span> <span class="n">NonlinearConstraint</span><span class="p">(</span><span class="n">cons_f</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">cons_J</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">BFGS</span><span class="p">())</span>
</pre></div>
</div>
<p>Alternatively, the Hessian may be approximated using finite differences.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinear_constraint</span> <span class="o">=</span> <span class="n">NonlinearConstraint</span><span class="p">(</span><span class="n">cons_f</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">cons_J</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="s1">&#39;2-point&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The Jacobian of the constraints can be approximated by finite differences as well. In this case,
however, the Hessian cannot be computed with finite differences and needs to
be provided by the user or defined using <a class="reference internal" href="../reference/generated/scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy" title="scipy.optimize.HessianUpdateStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">HessianUpdateStrategy</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinear_constraint</span> <span class="o">=</span> <span class="n">NonlinearConstraint</span><span class="p">(</span><span class="n">cons_f</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="s1">&#39;2-point&#39;</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">BFGS</span><span class="p">())</span>
</pre></div>
</div>
<p><strong>Solving the Optimization Problem</strong>
The optimization problem is solved using:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">rosen_hess</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">constraints</span><span class="o">=</span><span class="p">[</span><span class="n">linear_constraint</span><span class="p">,</span> <span class="n">nonlinear_constraint</span><span class="p">],</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="go"># may vary</span>
<span class="go">`gtol` termination condition is satisfied.</span>
<span class="go">Number of iterations: 12, function evaluations: 8, CG iterations: 7, optimality: 2.99e-09, constraint violation: 1.11e-16, execution time: 0.016 s.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[0.41494531 0.17010937]</span>
</pre></div>
</div>
<p>When needed, the objective function Hessian can be defined using a <a class="reference internal" href="../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearOperator</span></code></a> object,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rosen_hess_linop</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">matvec</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">rosen_hess_p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">LinearOperator</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">matvec</span><span class="o">=</span><span class="n">matvec</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">rosen_hess_linop</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">constraints</span><span class="o">=</span><span class="p">[</span><span class="n">linear_constraint</span><span class="p">,</span> <span class="n">nonlinear_constraint</span><span class="p">],</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="go"># may vary</span>
<span class="go">`gtol` termination condition is satisfied.</span>
<span class="go">Number of iterations: 12, function evaluations: 8, CG iterations: 7, optimality: 2.99e-09, constraint violation: 1.11e-16, execution time: 0.018 s.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[0.41494531 0.17010937]</span>
</pre></div>
</div>
<p>or a Hessian-vector product through the parameter <code class="docutils literal notranslate"><span class="pre">hessp</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span> <span class="n">hessp</span><span class="o">=</span><span class="n">rosen_hess_p</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">constraints</span><span class="o">=</span><span class="p">[</span><span class="n">linear_constraint</span><span class="p">,</span> <span class="n">nonlinear_constraint</span><span class="p">],</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="go"># may vary</span>
<span class="go">`gtol` termination condition is satisfied.</span>
<span class="go">Number of iterations: 12, function evaluations: 8, CG iterations: 7, optimality: 2.99e-09, constraint violation: 1.11e-16, execution time: 0.018 s.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[0.41494531 0.17010937]</span>
</pre></div>
</div>
<p>Alternatively, the first and second derivatives of the objective function can be approximated.
For instance,  the Hessian can be approximated with <a class="reference internal" href="../reference/generated/scipy.optimize.SR1.html#scipy.optimize.SR1" title="scipy.optimize.SR1"><code class="xref py py-func docutils literal notranslate"><span class="pre">SR1</span></code></a> quasi-Newton approximation
and the gradient with finite differences.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">SR1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span>  <span class="n">jac</span><span class="o">=</span><span class="s2">&quot;2-point&quot;</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">SR1</span><span class="p">(),</span>
<span class="gp">... </span>               <span class="n">constraints</span><span class="o">=</span><span class="p">[</span><span class="n">linear_constraint</span><span class="p">,</span> <span class="n">nonlinear_constraint</span><span class="p">],</span>
<span class="gp">... </span>               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="go"># may vary</span>
<span class="go">`gtol` termination condition is satisfied.</span>
<span class="go">Number of iterations: 12, function evaluations: 24, CG iterations: 7, optimality: 4.48e-09, constraint violation: 0.00e+00, execution time: 0.016 s.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[0.41494531 0.17010937]</span>
</pre></div>
</div>
<div role="list" class="citation-list">
<div class="citation" id="trip" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">TRIP</a><span class="fn-bracket">]</span></span>
<p>Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999.
An interior point algorithm for large-scale nonlinear  programming.
SIAM Journal on Optimization 9.4: 877-900.</p>
</div>
<div class="citation" id="eqsqp" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">EQSQP</a><span class="fn-bracket">]</span></span>
<p>Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998. On the
implementation of an algorithm for large-scale equality constrained
optimization. SIAM Journal on Optimization 8.3: 682-706.</p>
</div>
</div>
</section>
<section id="sequential-least-squares-programming-slsqp-algorithm-method-slsqp">
<h4><a class="toc-backref" href="#id27" role="doc-backlink">Sequential Least SQuares Programming (SLSQP) Algorithm (<code class="docutils literal notranslate"><span class="pre">method='SLSQP'</span></code>)</a><a class="headerlink" href="#sequential-least-squares-programming-slsqp-algorithm-method-slsqp" title="Link to this heading">#</a></h4>
<p>The SLSQP method deals with constrained minimization problems of the form:</p>
<div class="math notranslate nohighlight">
  \begin{eqnarray*} \min_x &amp; f(x) \\
       \text{subject to: } &amp; c_j(x) =  0  ,  &amp;j \in \mathcal{E}\\
         &amp; c_j(x) \geq 0  ,  &amp;j \in \mathcal{I}\\
        &amp;  \text{lb}_i  \leq x_i \leq \text{ub}_i , &amp;i = 1,...,N. \end{eqnarray*}</div><p>Where <span class="math notranslate nohighlight">\(\mathcal{E}\)</span> or <span class="math notranslate nohighlight">\(\mathcal{I}\)</span> are sets of indices
containing equality and inequality constraints.</p>
<p>Both linear and nonlinear constraints are defined as dictionaries with keys <code class="docutils literal notranslate"><span class="pre">type</span></code>, <code class="docutils literal notranslate"><span class="pre">fun</span></code> and <code class="docutils literal notranslate"><span class="pre">jac</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ineq_cons</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="s1">&#39;fun&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                                         <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                                         <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
<span class="gp">... </span>             <span class="s1">&#39;jac&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">],</span>
<span class="gp">... </span>                                         <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span>
<span class="gp">... </span>                                         <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">]])}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq_cons</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="s1">&#39;fun&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span>
<span class="gp">... </span>           <span class="s1">&#39;jac&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])}</span>
</pre></div>
</div>
<p>And the optimization problem is solved with:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">rosen_der</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">constraints</span><span class="o">=</span><span class="p">[</span><span class="n">eq_cons</span><span class="p">,</span> <span class="n">ineq_cons</span><span class="p">],</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;ftol&#39;</span><span class="p">:</span> <span class="mf">1e-9</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
<span class="gp">... </span>               <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="go"># may vary</span>
<span class="go">Optimization terminated successfully.    (Exit mode 0)</span>
<span class="go">            Current function value: 0.342717574857755</span>
<span class="go">            Iterations: 5</span>
<span class="go">            Function evaluations: 6</span>
<span class="go">            Gradient evaluations: 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">[0.41494475 0.1701105 ]</span>
</pre></div>
</div>
<p>Most of the options available for the method <code class="docutils literal notranslate"><span class="pre">'trust-constr'</span></code> are not available
for <code class="docutils literal notranslate"><span class="pre">'SLSQP'</span></code>.</p>
</section>
</section>
<section id="local-minimization-solver-comparison">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">Local minimization solver comparison</a><a class="headerlink" href="#local-minimization-solver-comparison" title="Link to this heading">#</a></h3>
<p>Find a solver that meets your requirements using the table below.
If there are multiple candidates, try several and see which ones best
meet your needs (e.g. execution time, objective function value).</p>
<div class="pst-scrollable-table-container"><table class="table">
<colgroup>
<col style="width: 15.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 15.0%" />
<col style="width: 15.0%" />
<col style="width: 15.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Solver</p></th>
<th class="head"><p>Bounds Constraints</p></th>
<th class="head"><p>Nonlinear Constraints</p></th>
<th class="head"><p>Uses Gradient</p></th>
<th class="head"><p>Uses Hessian</p></th>
<th class="head"><p>Utilizes Sparsity</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CG</p></td>
<td></td>
<td></td>
<td><p>✓</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>BFGS</p></td>
<td></td>
<td></td>
<td><p>✓</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>dogleg</p></td>
<td></td>
<td></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>trust-ncg</p></td>
<td></td>
<td></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>trust-krylov</p></td>
<td></td>
<td></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>trust-exact</p></td>
<td></td>
<td></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Newton-CG</p></td>
<td></td>
<td></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
</tr>
<tr class="row-odd"><td><p>Nelder-Mead</p></td>
<td><p>✓</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Powell</p></td>
<td><p>✓</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>L-BFGS-B</p></td>
<td><p>✓</p></td>
<td></td>
<td><p>✓</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TNC</p></td>
<td><p>✓</p></td>
<td></td>
<td><p>✓</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>COBYLA</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>SLSQP</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>trust-constr</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
</tr>
</tbody>
</table>
</div>
</section>
</section>
<section id="global-optimization">
<h2><a class="toc-backref" href="#id29" role="doc-backlink">Global optimization</a><a class="headerlink" href="#global-optimization" title="Link to this heading">#</a></h2>
<p>Global optimization aims to find the global minimum of a function within given
bounds, in the presence of potentially many local minima. Typically, global
minimizers efficiently search the parameter space, while using a local
minimizer (e.g., <a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a>) under the hood.  SciPy contains a
number of good global optimizers.  Here, we’ll use those on the same objective
function, namely the (aptly named) <code class="docutils literal notranslate"><span class="pre">eggholder</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">eggholder</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">47</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span> <span class="mi">47</span><span class="p">))))</span>
<span class="gp">... </span>            <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span> <span class="mi">47</span><span class="p">)))))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)]</span>
</pre></div>
</div>
<p>This function looks like an egg carton:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">512</span><span class="p">,</span> <span class="mi">513</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">512</span><span class="p">,</span> <span class="mi">513</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xgrid</span><span class="p">,</span> <span class="n">ygrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">ygrid</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="o">-</span><span class="mi">45</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">ygrid</span><span class="p">,</span> <span class="n">eggholder</span><span class="p">(</span><span class="n">xy</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;terrain&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;eggholder(x, y)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center">
<img alt="&quot;A 3-D plot shown from a three-quarter view. The function is very noisy with dozens of valleys and peaks. There is no clear min or max discernible from this view and it's not possible to see all the local peaks and valleys from this view.&quot;" class="plot-directive" src="../_images/optimize_global_2.png" />
</figure>
<p>We now use the global optimizers to obtain the minimum and the function value
at the minimum. We’ll store the results in a dictionary so we can compare
different optimization results later.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;shgo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">shgo</span><span class="p">(</span><span class="n">eggholder</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;shgo&#39;</span><span class="p">]</span>
<span class="go">     fun: -935.3379515604197  # may vary</span>
<span class="go">    funl: array([-935.33795156])</span>
<span class="go"> message: &#39;Optimization terminated successfully.&#39;</span>
<span class="go">    nfev: 42</span>
<span class="go">     nit: 2</span>
<span class="go">   nlfev: 37</span>
<span class="go">   nlhev: 0</span>
<span class="go">   nljev: 9</span>
<span class="go"> success: True</span>
<span class="go">       x: array([439.48096952, 453.97740589])</span>
<span class="go">      xl: array([[439.48096952, 453.97740589]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;DA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">dual_annealing</span><span class="p">(</span><span class="n">eggholder</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;DA&#39;</span><span class="p">]</span>
<span class="go">     fun: -956.9182316237413  # may vary</span>
<span class="go"> message: [&#39;Maximum number of iteration reached&#39;]</span>
<span class="go">    nfev: 4091</span>
<span class="go">    nhev: 0</span>
<span class="go">     nit: 1000</span>
<span class="go">    njev: 0</span>
<span class="go">       x: array([482.35324114, 432.87892901])</span>
</pre></div>
</div>
<p>All optimizers return an <code class="docutils literal notranslate"><span class="pre">OptimizeResult</span></code>, which in addition to the solution
contains information on the number of function evaluations, whether the
optimization was successful, and more.  For brevity, we won’t show the full
output of the other optimizers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;DE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">differential_evolution</span><span class="p">(</span><span class="n">eggholder</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/generated/scipy.optimize.shgo.html#scipy.optimize.shgo" title="scipy.optimize.shgo"><code class="xref py py-func docutils literal notranslate"><span class="pre">shgo</span></code></a> has a second method, which returns all local minima rather than
only what it thinks is the global minimum:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;shgo_sobol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">shgo</span><span class="p">(</span><span class="n">eggholder</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">sampling_method</span><span class="o">=</span><span class="s1">&#39;sobol&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We’ll now plot all found minima on a heatmap of the function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">eggholder</span><span class="p">(</span><span class="n">xy</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">plot_point</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">512</span><span class="o">+</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">512</span><span class="o">+</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_point</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;DE&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>  <span class="c1"># differential_evolution - cyan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_point</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;DA&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>  <span class="c1"># dual_annealing.        - white</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># SHGO produces multiple minima, plot them all (with a smaller marker size)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_point</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;shgo&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_point</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;shgo_sobol&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;shgo_sobol&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">xl</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">512</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;shgo_sobol&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">xl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>            <span class="mi">512</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;shgo_sobol&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">xl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>            <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">514</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">514</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center">
<img alt="&quot;This X-Y plot is a heatmap with the Z value denoted with the lowest points as black and the highest values as white. The image resembles a chess board rotated 45 degrees but heavily smoothed. A red dot is located at many of the minima on the grid resulting from the SHGO optimizer. SHGO shows the global minima as a red X in the top right. A local minima found with dual annealing is a white circle marker in the top left. A different local minima found with basinhopping is a yellow marker in the top center. The code is plotting the differential evolution result as a cyan circle, but it is not visible on the plot. At a glance it's not clear which of these valleys is the true global minima.&quot;" class="plot-directive" src="../_images/optimize_global_1.png" />
</figure>
<section id="comparison-of-global-optimizers">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">Comparison of Global Optimizers</a><a class="headerlink" href="#comparison-of-global-optimizers" title="Link to this heading">#</a></h3>
<p>Find a solver that meets your requirements using the table below.
If there are multiple candidates, try several and see which ones best
meet your needs (e.g. execution time, objective function value).</p>
<div class="pst-scrollable-table-container"><table class="table">
<colgroup>
<col style="width: 22.2%" />
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 22.2%" />
<col style="width: 22.2%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Solver</p></th>
<th class="head"><p>Bounds Constraints</p></th>
<th class="head"><p>Nonlinear Constraints</p></th>
<th class="head"><p>Uses Gradient</p></th>
<th class="head"><p>Uses Hessian</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>basinhopping</p></td>
<td></td>
<td></td>
<td><p>(✓)</p></td>
<td><p>(✓)</p></td>
</tr>
<tr class="row-odd"><td><p>direct</p></td>
<td><p>✓</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>dual_annealing</p></td>
<td><p>✓</p></td>
<td></td>
<td><p>(✓)</p></td>
<td><p>(✓)</p></td>
</tr>
<tr class="row-odd"><td><p>differential_evolution</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>shgo</p></td>
<td><p>✓</p></td>
<td><p>✓</p></td>
<td><p>(✓)</p></td>
<td><p>(✓)</p></td>
</tr>
</tbody>
</table>
</div>
<p>(✓) = Depending on the chosen local minimizer</p>
</section>
</section>
<section id="least-squares-minimization-least-squares">
<h2><a class="toc-backref" href="#id31" role="doc-backlink">Least-squares minimization (<a class="reference internal" href="../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-func docutils literal notranslate"><span class="pre">least_squares</span></code></a>)</a><a class="headerlink" href="#least-squares-minimization-least-squares" title="Link to this heading">#</a></h2>
<p>SciPy is capable of solving robustified bound-constrained nonlinear
least-squares problems:</p>
<div class="math notranslate nohighlight">
\begin{align}
&amp;\min_\mathbf{x} \frac{1}{2} \sum_{i = 1}^m \rho\left(f_i(\mathbf{x})^2\right) \\
&amp;\text{subject to }\mathbf{lb} \leq \mathbf{x} \leq \mathbf{ub}
\end{align}</div><p>Here <span class="math notranslate nohighlight">\(f_i(\mathbf{x})\)</span> are smooth functions from
<span class="math notranslate nohighlight">\(\mathbb{R}^n\)</span> to <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>, we refer to them as residuals.
The purpose of a scalar-valued function <span class="math notranslate nohighlight">\(\rho(\cdot)\)</span> is to reduce the
influence of outlier residuals and contribute to robustness of the solution,
we refer to it as a loss function. A linear loss function gives a standard
least-squares problem. Additionally, constraints in a form of lower and upper
bounds on some of <span class="math notranslate nohighlight">\(x_j\)</span> are allowed.</p>
<p>All methods specific to least-squares minimization utilize a <span class="math notranslate nohighlight">\(m \times n\)</span>
matrix of partial derivatives called Jacobian and defined as
<span class="math notranslate nohighlight">\(J_{ij} = \partial f_i / \partial x_j\)</span>. It is highly recommended to
compute this matrix analytically and pass it to <a class="reference internal" href="../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-func docutils literal notranslate"><span class="pre">least_squares</span></code></a>,
otherwise, it will be estimated by finite differences, which takes a lot of
additional time and can be very inaccurate in hard cases.</p>
<p>Function <a class="reference internal" href="../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-func docutils literal notranslate"><span class="pre">least_squares</span></code></a> can be used for fitting a function
<span class="math notranslate nohighlight">\(\varphi(t; \mathbf{x})\)</span> to empirical data <span class="math notranslate nohighlight">\(\{(t_i, y_i), i = 0, \ldots, m-1\}\)</span>.
To do this, one should simply precompute residuals as
<span class="math notranslate nohighlight">\(f_i(\mathbf{x}) = w_i (\varphi(t_i; \mathbf{x}) - y_i)\)</span>, where <span class="math notranslate nohighlight">\(w_i\)</span>
are weights assigned to each observation.</p>
<section id="example-of-solving-a-fitting-problem">
<h3><a class="toc-backref" href="#id32" role="doc-backlink">Example of solving a fitting problem</a><a class="headerlink" href="#example-of-solving-a-fitting-problem" title="Link to this heading">#</a></h3>
<p>Here we consider an enzymatic reaction <a class="footnote-reference brackets" href="#id11" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. There are 11 residuals defined as</p>
<div class="math notranslate nohighlight">
\[f_i(x) = \frac{x_0 (u_i^2 + u_i x_1)}{u_i^2 + u_i x_2 + x_3} - y_i, \quad i = 0, \ldots, 10,\]</div>
<p>where <span class="math notranslate nohighlight">\(y_i\)</span> are measurement values and <span class="math notranslate nohighlight">\(u_i\)</span> are values of
the independent variable. The unknown vector of parameters is
<span class="math notranslate nohighlight">\(\mathbf{x} = (x_0, x_1, x_2, x_3)^T\)</span>. As was said previously, it is
recommended to compute Jacobian matrix in a closed form:</p>
<div class="math notranslate nohighlight">
 \begin{align}
 &amp;J_{i0} = \frac{\partial f_i}{\partial x_0} = \frac{u_i^2 + u_i x_1}{u_i^2 + u_i x_2 + x_3} \\
 &amp;J_{i1} = \frac{\partial f_i}{\partial x_1} = \frac{u_i x_0}{u_i^2 + u_i x_2 + x_3} \\
 &amp;J_{i2} = \frac{\partial f_i}{\partial x_2} = -\frac{x_0 (u_i^2 + u_i x_1) u_i}{(u_i^2 + u_i x_2 + x_3)^2} \\
 &amp;J_{i3} = \frac{\partial f_i}{\partial x_3} = -\frac{x_0 (u_i^2 + u_i x_1)}{(u_i^2 + u_i x_2 + x_3)^2}
 \end{align}</div><p>We are going to use the “hard” starting point defined in <a class="footnote-reference brackets" href="#id12" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. To find a
physically meaningful solution, avoid potential division by zero and assure
convergence to the global minimum we impose constraints
<span class="math notranslate nohighlight">\(0 \leq x_j \leq 100, j = 0, 1, 2, 3\)</span>.</p>
<p>The code below implements least-squares estimation of <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> and
finally plots the original data and the fitted model function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">least_squares</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">jac</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">u</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">den</span> <span class="o">=</span> <span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">num</span> <span class="o">=</span> <span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span>
<span class="gp">... </span>    <span class="n">J</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
<span class="gp">... </span>    <span class="n">J</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span> <span class="o">/</span> <span class="n">den</span>
<span class="gp">... </span>    <span class="n">J</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num</span> <span class="o">*</span> <span class="n">u</span> <span class="o">/</span> <span class="n">den</span> <span class="o">**</span> <span class="mi">2</span>
<span class="gp">... </span>    <span class="n">J</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span> <span class="o">**</span> <span class="mi">2</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">J</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0e-1</span><span class="p">,</span> <span class="mf">2.5e-1</span><span class="p">,</span> <span class="mf">1.67e-1</span><span class="p">,</span> <span class="mf">1.25e-1</span><span class="p">,</span> <span class="mf">1.0e-1</span><span class="p">,</span>
<span class="gp">... </span>              <span class="mf">8.33e-2</span><span class="p">,</span> <span class="mf">7.14e-2</span><span class="p">,</span> <span class="mf">6.25e-2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.957e-1</span><span class="p">,</span> <span class="mf">1.947e-1</span><span class="p">,</span> <span class="mf">1.735e-1</span><span class="p">,</span> <span class="mf">1.6e-1</span><span class="p">,</span> <span class="mf">8.44e-2</span><span class="p">,</span> <span class="mf">6.27e-2</span><span class="p">,</span>
<span class="gp">... </span>              <span class="mf">4.56e-2</span><span class="p">,</span> <span class="mf">3.42e-2</span><span class="p">,</span> <span class="mf">3.23e-2</span><span class="p">,</span> <span class="mf">2.35e-2</span><span class="p">,</span> <span class="mf">2.46e-2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.9</span><span class="p">,</span> <span class="mf">4.15</span><span class="p">,</span> <span class="mf">3.9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># may vary</span>
<span class="go">`ftol` termination condition is satisfied.</span>
<span class="go">Function evaluations 130, initial cost 4.4383e+00, final cost 1.5375e-04, first-order optimality 4.92e-08.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 0.19280596,  0.19130423,  0.12306063,  0.13607247])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_test</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">u_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">u_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;fitted model&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="&quot;This code plots an X-Y time-series. The series starts in the lower left at (0, 0) and rapidly trends up to the maximum of 0.2 then flattens out. The fitted model is shown as a smooth orange trace and is well fit to the data.&quot;" class="plot-directive" src="../_images/optimize-1.png" />
</figure>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">1</a><span class="fn-bracket">]</span></span>
<p>J. Kowalik and J. F. Morrison, “Analysis of kinetic data for allosteric enzyme reactions as
a nonlinear regression problem”, Math. Biosci., vol. 2, pp. 57-66, 1968.</p>
</aside>
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">2</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="2">
<li><ol class="upperalpha simple" start="13">
<li><p>Averick et al., “The MINPACK-2 Test Problem Collection”.</p></li>
</ol>
</li>
</ol>
</aside>
</aside>
</section>
<section id="further-examples">
<h3><a class="toc-backref" href="#id33" role="doc-backlink">Further examples</a><a class="headerlink" href="#further-examples" title="Link to this heading">#</a></h3>
<p>Three interactive examples below illustrate usage of <a class="reference internal" href="../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-func docutils literal notranslate"><span class="pre">least_squares</span></code></a> in
greater detail.</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://scipy-cookbook.readthedocs.io/items/bundle_adjustment.html">Large-scale bundle adjustment in scipy</a>
demonstrates large-scale capabilities of <a class="reference internal" href="../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-func docutils literal notranslate"><span class="pre">least_squares</span></code></a> and how to
efficiently compute finite difference approximation of sparse Jacobian.</p></li>
<li><p><a class="reference external" href="https://scipy-cookbook.readthedocs.io/items/robust_regression.html">Robust nonlinear regression in scipy</a>
shows how to handle outliers with a robust loss function in a nonlinear
regression.</p></li>
<li><p><a class="reference external" href="https://scipy-cookbook.readthedocs.io/items/discrete_bvp.html">Solving a discrete boundary-value problem in scipy</a>
examines how to solve a large system of equations and use bounds to achieve
desired properties of the solution.</p></li>
</ol>
<p>For the details about mathematical algorithms behind the implementation refer
to documentation of <a class="reference internal" href="../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-func docutils literal notranslate"><span class="pre">least_squares</span></code></a>.</p>
</section>
</section>
<section id="univariate-function-minimizers-minimize-scalar">
<h2><a class="toc-backref" href="#id34" role="doc-backlink">Univariate function minimizers (<a class="reference internal" href="../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize_scalar</span></code></a>)</a><a class="headerlink" href="#univariate-function-minimizers-minimize-scalar" title="Link to this heading">#</a></h2>
<p>Often only the minimum of an univariate function (i.e., a function that
takes a scalar as input) is needed. In these circumstances, other
optimization techniques have been developed that can work faster. These are
accessible from the <a class="reference internal" href="../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize_scalar</span></code></a> function, which proposes several
algorithms.</p>
<section id="unconstrained-minimization-method-brent">
<h3><a class="toc-backref" href="#id35" role="doc-backlink">Unconstrained minimization (<code class="docutils literal notranslate"><span class="pre">method='brent'</span></code>)</a><a class="headerlink" href="#unconstrained-minimization-method-brent" title="Link to this heading">#</a></h3>
<p>There are, actually, two methods that can be used to minimize an univariate
function: <a class="reference internal" href="../reference/generated/scipy.optimize.brent.html#scipy.optimize.brent" title="scipy.optimize.brent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">brent</span></code></a> and <a class="reference internal" href="../reference/generated/scipy.optimize.golden.html#scipy.optimize.golden" title="scipy.optimize.golden"><code class="xref py py-obj docutils literal notranslate"><span class="pre">golden</span></code></a>, but <a class="reference internal" href="../reference/generated/scipy.optimize.golden.html#scipy.optimize.golden" title="scipy.optimize.golden"><code class="xref py py-obj docutils literal notranslate"><span class="pre">golden</span></code></a> is included only for academic
purposes and should rarely be used. These can be respectively selected
through the <em class="xref py py-obj">method</em> parameter in <a class="reference internal" href="../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize_scalar</span></code></a>. The <a class="reference internal" href="../reference/generated/scipy.optimize.brent.html#scipy.optimize.brent" title="scipy.optimize.brent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">brent</span></code></a>
method uses Brent’s algorithm for locating a minimum. Optimally, a bracket
(the <a class="reference internal" href="../reference/generated/scipy.optimize.bracket.html#scipy.optimize.bracket" title="scipy.optimize.bracket"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bracket</span></code></a> parameter) should be given which contains the minimum desired. A
bracket is a triple <span class="math notranslate nohighlight">\(\left( a, b, c \right)\)</span> such that <span class="math notranslate nohighlight">\(f
\left( a \right) &gt; f \left( b \right) &lt; f \left( c \right)\)</span> and <span class="math notranslate nohighlight">\(a &lt;
b &lt; c\)</span> . If this is not given, then alternatively two starting points can
be chosen and a bracket will be found from these points using a simple
marching algorithm. If these two starting points are not provided, <em class="xref py py-obj">0</em> and
<em class="xref py py-obj">1</em> will be used (this may not be the right choice for your function and
result in an unexpected minimum being returned).</p>
<p>Here is an example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize_scalar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brent&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</section>
<section id="bounded-minimization-method-bounded">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">Bounded minimization (<code class="docutils literal notranslate"><span class="pre">method='bounded'</span></code>)</a><a class="headerlink" href="#bounded-minimization-method-bounded" title="Link to this heading">#</a></h3>
<p>Very often, there are constraints that can be placed on the solution space
before minimization occurs. The <em class="xref py py-obj">bounded</em> method in <a class="reference internal" href="../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize_scalar</span></code></a>
is an example of a constrained minimization procedure that provides a
rudimentary interval constraint for scalar functions. The interval
constraint allows the minimization to occur only between two fixed
endpoints, specified using the mandatory <em class="xref py py-obj">bounds</em> parameter.</p>
<p>For example, to find the minimum of <span class="math notranslate nohighlight">\(J_{1}\left( x \right)\)</span> near
<span class="math notranslate nohighlight">\(x=5\)</span> , <a class="reference internal" href="../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar" title="scipy.optimize.minimize_scalar"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize_scalar</span></code></a> can be called using the interval
<span class="math notranslate nohighlight">\(\left[ 4, 7 \right]\)</span> as a constraint. The result is
<span class="math notranslate nohighlight">\(x_{\textrm{min}}=5.3314\)</span> :</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">j1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bounded&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">5.33144184241</span>
</pre></div>
</div>
</section>
</section>
<section id="custom-minimizers">
<h2><a class="toc-backref" href="#id37" role="doc-backlink">Custom minimizers</a><a class="headerlink" href="#custom-minimizers" title="Link to this heading">#</a></h2>
<p>Sometimes, it may be useful to use a custom method as a (multivariate
or univariate) minimizer, for example, when using some library wrappers
of <a class="reference internal" href="../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="scipy.optimize.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code></a> (e.g., <a class="reference internal" href="../reference/generated/scipy.optimize.basinhopping.html#scipy.optimize.basinhopping" title="scipy.optimize.basinhopping"><code class="xref py py-func docutils literal notranslate"><span class="pre">basinhopping</span></code></a>).</p>
<p>We can achieve that by, instead of passing a method name, passing
a callable (either a function or an object implementing a <em class="xref py py-obj">__call__</em>
method) as the <em class="xref py py-obj">method</em> parameter.</p>
<p>Let us consider an (admittedly rather virtual) need to use a trivial
custom multivariate minimization method that will just search the
neighborhood in each dimension independently with a fixed step size:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">OptimizeResult</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">custmin</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">maxfev</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">bestx</span> <span class="o">=</span> <span class="n">x0</span>
<span class="gp">... </span>    <span class="n">besty</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">funcalls</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="n">improved</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">improved</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stop</span> <span class="ow">and</span> <span class="n">niter</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">improved</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">... </span>        <span class="n">niter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x0</span><span class="p">)):</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="n">bestx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">-</span> <span class="n">stepsize</span><span class="p">,</span> <span class="n">bestx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">stepsize</span><span class="p">]:</span>
<span class="gp">... </span>                <span class="n">testx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">bestx</span><span class="p">)</span>
<span class="gp">... </span>                <span class="n">testx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
<span class="gp">... </span>                <span class="n">testy</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">testx</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">... </span>                <span class="n">funcalls</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>                <span class="k">if</span> <span class="n">testy</span> <span class="o">&lt;</span> <span class="n">besty</span><span class="p">:</span>
<span class="gp">... </span>                    <span class="n">besty</span> <span class="o">=</span> <span class="n">testy</span>
<span class="gp">... </span>                    <span class="n">bestx</span> <span class="o">=</span> <span class="n">testx</span>
<span class="gp">... </span>                    <span class="n">improved</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">callback</span><span class="p">(</span><span class="n">bestx</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">maxfev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">funcalls</span> <span class="o">&gt;=</span> <span class="n">maxfev</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">... </span>                <span class="k">break</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">OptimizeResult</span><span class="p">(</span><span class="n">fun</span><span class="o">=</span><span class="n">besty</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">bestx</span><span class="p">,</span> <span class="n">nit</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">nfev</span><span class="o">=</span><span class="n">funcalls</span><span class="p">,</span> <span class="n">success</span><span class="o">=</span><span class="p">(</span><span class="n">niter</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.35</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">rosen</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">custmin</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">stepsize</span><span class="o">=</span><span class="mf">0.05</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
</pre></div>
</div>
<p>This will work just as well in case of univariate optimization:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">custmin</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">bracket</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">maxfev</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">bestx</span> <span class="o">=</span> <span class="p">(</span><span class="n">bracket</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bracket</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="gp">... </span>    <span class="n">besty</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">bestx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">funcalls</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="n">improved</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">improved</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stop</span> <span class="ow">and</span> <span class="n">niter</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">improved</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">... </span>        <span class="n">niter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">testx</span> <span class="ow">in</span> <span class="p">[</span><span class="n">bestx</span> <span class="o">-</span> <span class="n">stepsize</span><span class="p">,</span> <span class="n">bestx</span> <span class="o">+</span> <span class="n">stepsize</span><span class="p">]:</span>
<span class="gp">... </span>            <span class="n">testy</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">testx</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">... </span>            <span class="n">funcalls</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">testy</span> <span class="o">&lt;</span> <span class="n">besty</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">besty</span> <span class="o">=</span> <span class="n">testy</span>
<span class="gp">... </span>                <span class="n">bestx</span> <span class="o">=</span> <span class="n">testx</span>
<span class="gp">... </span>                <span class="n">improved</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">callback</span><span class="p">(</span><span class="n">bestx</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">maxfev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">funcalls</span> <span class="o">&gt;=</span> <span class="n">maxfev</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">... </span>            <span class="k">break</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">OptimizeResult</span><span class="p">(</span><span class="n">fun</span><span class="o">=</span><span class="n">besty</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">bestx</span><span class="p">,</span> <span class="n">nit</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">nfev</span><span class="o">=</span><span class="n">funcalls</span><span class="p">,</span> <span class="n">success</span><span class="o">=</span><span class="p">(</span><span class="n">niter</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">3.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">custmin</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">stepsize</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">-2.0</span>
</pre></div>
</div>
</section>
<section id="root-finding">
<h2><a class="toc-backref" href="#id38" role="doc-backlink">Root finding</a><a class="headerlink" href="#root-finding" title="Link to this heading">#</a></h2>
<section id="scalar-functions">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">Scalar functions</a><a class="headerlink" href="#scalar-functions" title="Link to this heading">#</a></h3>
<p>If one has a single-variable equation, there are multiple different root
finding algorithms that can be tried. Most of these algorithms require the
endpoints of an interval in which a root is expected (because the function
changes signs). In general, <a class="reference internal" href="../reference/generated/scipy.optimize.brentq.html#scipy.optimize.brentq" title="scipy.optimize.brentq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">brentq</span></code></a> is the best choice, but the other
methods may be useful in certain circumstances or for academic purposes.
When a bracket is not available, but one or more derivatives are available,
then <a class="reference internal" href="../reference/generated/scipy.optimize.newton.html#scipy.optimize.newton" title="scipy.optimize.newton"><code class="xref py py-obj docutils literal notranslate"><span class="pre">newton</span></code></a> (or <code class="docutils literal notranslate"><span class="pre">halley</span></code>, <code class="docutils literal notranslate"><span class="pre">secant</span></code>) may be applicable.
This is especially the case if the function is defined on a subset of the
complex plane, and the bracketing methods cannot be used.</p>
</section>
<section id="fixed-point-solving">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">Fixed-point solving</a><a class="headerlink" href="#fixed-point-solving" title="Link to this heading">#</a></h3>
<p>A problem closely related to finding the zeros of a function is the
problem of finding a fixed point of a function. A fixed point of a
function is the point at which evaluation of the function returns the
point: <span class="math notranslate nohighlight">\(g\left(x\right)=x.\)</span> Clearly, the fixed point of <span class="math notranslate nohighlight">\(g\)</span>
is the root of <span class="math notranslate nohighlight">\(f\left(x\right)=g\left(x\right)-x.\)</span>
Equivalently, the root of <span class="math notranslate nohighlight">\(f\)</span> is the fixed point of
<span class="math notranslate nohighlight">\(g\left(x\right)=f\left(x\right)+x.\)</span> The routine
<a class="reference internal" href="../reference/generated/scipy.optimize.fixed_point.html#scipy.optimize.fixed_point" title="scipy.optimize.fixed_point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fixed_point</span></code></a> provides a simple iterative method using Aitkens
sequence acceleration to estimate the fixed point of <span class="math notranslate nohighlight">\(g\)</span> given a
starting point.</p>
</section>
<section id="sets-of-equations">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">Sets of equations</a><a class="headerlink" href="#sets-of-equations" title="Link to this heading">#</a></h3>
<p>Finding a root of a set of non-linear equations can be achieved using the
<a class="reference internal" href="../reference/generated/scipy.optimize.root.html#scipy.optimize.root" title="scipy.optimize.root"><code class="xref py py-func docutils literal notranslate"><span class="pre">root</span></code></a> function. Several methods are available, amongst which <code class="docutils literal notranslate"><span class="pre">hybr</span></code>
(the default) and <code class="docutils literal notranslate"><span class="pre">lm</span></code>, which, respectively, use the hybrid method of Powell
and the Levenberg-Marquardt method from MINPACK.</p>
<p>The following example considers the single-variable transcendental
equation</p>
<div class="math notranslate nohighlight">
\[x+2\cos\left(x\right)=0,\]</div>
<p>a root of which can be found as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([-1.02986653])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span><span class="o">.</span><span class="n">fun</span>
<span class="go">array([ -6.66133815e-16])</span>
</pre></div>
</div>
<p>Consider now a set of non-linear equations</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*}
 x_{0}\cos\left(x_{1}\right) &amp; = &amp; 4,\\
 x_{0}x_{1}-x_{1} &amp; = &amp; 5.
 \end{eqnarray*}</div><p>We define the objective function so that it also returns the Jacobian and
indicate this by setting the <code class="docutils literal notranslate"><span class="pre">jac</span></code> parameter to <code class="docutils literal notranslate"><span class="pre">True</span></code>. Also, the
Levenberg-Marquardt solver is used here.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>         <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">func2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lm&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 6.50409711,  0.90841421])</span>
</pre></div>
</div>
</section>
<section id="root-finding-for-large-problems">
<h3><a class="toc-backref" href="#id42" role="doc-backlink">Root finding for large problems</a><a class="headerlink" href="#root-finding-for-large-problems" title="Link to this heading">#</a></h3>
<p>Methods <code class="docutils literal notranslate"><span class="pre">hybr</span></code> and <code class="docutils literal notranslate"><span class="pre">lm</span></code> in <a class="reference internal" href="../reference/generated/scipy.optimize.root.html#scipy.optimize.root" title="scipy.optimize.root"><code class="xref py py-func docutils literal notranslate"><span class="pre">root</span></code></a> cannot deal with a very large
number of variables (<em>N</em>), as they need to calculate and invert a dense <em>N
x N</em> Jacobian matrix on every Newton step. This becomes rather inefficient
when <em>N</em> grows.</p>
<p>Consider, for instance, the following problem: we need to solve the
following integrodifferential equation on the square
<span class="math notranslate nohighlight">\([0,1]\times[0,1]\)</span>:</p>
<div class="math notranslate nohighlight">
\[(\partial_x^2 + \partial_y^2) P + 5 \left(\int_0^1\int_0^1\cosh(P)\,dx\,dy\right)^2 = 0\]</div>
<p>with the boundary condition <span class="math notranslate nohighlight">\(P(x,1) = 1\)</span> on the upper edge and
<span class="math notranslate nohighlight">\(P=0\)</span> elsewhere on the boundary of the square. This can be done
by approximating the continuous function <em>P</em> by its values on a grid,
<span class="math notranslate nohighlight">\(P_{n,m}\approx{}P(n h, m h)\)</span>, with a small grid spacing
<em>h</em>. The derivatives and integrals can then be approximated; for
instance <span class="math notranslate nohighlight">\(\partial_x^2 P(x,y)\approx{}(P(x+h,y) - 2 P(x,y) +
P(x-h,y))/h^2\)</span>. The problem is then equivalent to finding the root of
some function <code class="docutils literal notranslate"><span class="pre">residual(P)</span></code>, where <code class="docutils literal notranslate"><span class="pre">P</span></code> is a vector of length
<span class="math notranslate nohighlight">\(N_x N_y\)</span>.</p>
<p>Now, because <span class="math notranslate nohighlight">\(N_x N_y\)</span> can be large, methods <code class="docutils literal notranslate"><span class="pre">hybr</span></code> or <code class="docutils literal notranslate"><span class="pre">lm</span></code> in
<a class="reference internal" href="../reference/generated/scipy.optimize.root.html#scipy.optimize.root" title="scipy.optimize.root"><code class="xref py py-func docutils literal notranslate"><span class="pre">root</span></code></a> will take a long time to solve this problem. The solution can,
however, be found using one of the large-scale solvers, for example
<code class="docutils literal notranslate"><span class="pre">krylov</span></code>, <code class="docutils literal notranslate"><span class="pre">broyden2</span></code>, or <code class="docutils literal notranslate"><span class="pre">anderson</span></code>. These use what is known as the
inexact Newton method, which instead of computing the Jacobian matrix
exactly, forms an approximation for it.</p>
<p>The problem we have can now be solved as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">,</span> <span class="n">zeros</span>

<span class="c1"># parameters</span>
<span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">75</span>
<span class="n">hx</span><span class="p">,</span> <span class="n">hy</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">P_left</span><span class="p">,</span> <span class="n">P_right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">P_top</span><span class="p">,</span> <span class="n">P_bottom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
   <span class="n">d2x</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
   <span class="n">d2y</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

   <span class="n">d2x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>   <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
   <span class="n">d2x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>    <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">+</span> <span class="n">P_left</span><span class="p">)</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
   <span class="n">d2x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">P_right</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>

   <span class="n">d2y</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
   <span class="n">d2y</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>  <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    <span class="o">+</span> <span class="n">P_bottom</span><span class="p">)</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
   <span class="n">d2y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">P_top</span>   <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">+</span> <span class="n">P</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>

   <span class="k">return</span> <span class="n">d2x</span> <span class="o">+</span> <span class="n">d2y</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># solve</span>
<span class="n">guess</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">guess</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;krylov&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="c1">#sol = root(residual, guess, method=&#39;broyden2&#39;, options={&#39;disp&#39;: True, &#39;max_rank&#39;: 50})</span>
<span class="c1">#sol = root(residual, guess, method=&#39;anderson&#39;, options={&#39;disp&#39;: True, &#39;M&#39;: 10})</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Residual: </span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">abs</span><span class="p">(</span><span class="n">residual</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

<span class="c1"># visualize</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:(</span><span class="n">nx</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:(</span><span class="n">ny</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">)]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="s1">&#39;gouraud&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="&quot;This code generates a 2-D heatmap with Z values from 0 to 1. The graph resembles a smooth, dark blue-green, U shape, with an open yellow top. The right, bottom, and left edges have a value near zero and the top has a value close to 1. The center of the solution space has a value close to 0.8.&quot;" class="plot-directive" src="../_images/optimize-2.png" />
</figure>
</section>
<section id="still-too-slow-preconditioning">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">Still too slow? Preconditioning.</a><a class="headerlink" href="#still-too-slow-preconditioning" title="Link to this heading">#</a></h3>
<p>When looking for the zero of the functions <span class="math notranslate nohighlight">\(f_i({\bf x}) = 0\)</span>,
<em>i = 1, 2, …, N</em>, the <code class="docutils literal notranslate"><span class="pre">krylov</span></code> solver spends most of the
time inverting the Jacobian matrix,</p>
<div class="math notranslate nohighlight">
\[J_{ij} = \frac{\partial f_i}{\partial x_j} .\]</div>
<p>If you have an approximation for the inverse matrix
<span class="math notranslate nohighlight">\(M\approx{}J^{-1}\)</span>, you can use it for <em>preconditioning</em> the
linear-inversion problem. The idea is that instead of solving
<span class="math notranslate nohighlight">\(J{\bf s}={\bf y}\)</span> one solves <span class="math notranslate nohighlight">\(MJ{\bf s}=M{\bf y}\)</span>: since
matrix <span class="math notranslate nohighlight">\(MJ\)</span> is “closer” to the identity matrix than <span class="math notranslate nohighlight">\(J\)</span>
is, the equation should be easier for the Krylov method to deal with.</p>
<p>The matrix <em>M</em> can be passed to <a class="reference internal" href="../reference/generated/scipy.optimize.root.html#scipy.optimize.root" title="scipy.optimize.root"><code class="xref py py-func docutils literal notranslate"><span class="pre">root</span></code></a> with method <code class="docutils literal notranslate"><span class="pre">krylov</span></code> as an
option <code class="docutils literal notranslate"><span class="pre">options['jac_options']['inner_M']</span></code>. It can be a (sparse) matrix
or a <a class="reference internal" href="../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.LinearOperator</span></code></a> instance.</p>
<p>For the problem in the previous section, we note that the function to
solve consists of two parts: the first one is the application of the
Laplace operator, <span class="math notranslate nohighlight">\([\partial_x^2 + \partial_y^2] P\)</span>, and the second
is the integral. We can actually easily compute the Jacobian corresponding
to the Laplace operator part: we know that in 1-D</p>
<div class="math notranslate nohighlight">
\[\begin{split}\partial_x^2 \approx \frac{1}{h_x^2} \begin{pmatrix}
-2 &amp; 1 &amp; 0 &amp; 0 \cdots \\
1 &amp; -2 &amp; 1 &amp; 0 \cdots \\
0 &amp; 1 &amp; -2 &amp; 1 \cdots \\
\ldots
\end{pmatrix}
= h_x^{-2} L\end{split}\]</div>
<p>so that the whole 2-D operator is represented by</p>
<div class="math notranslate nohighlight">
\[J_1 = \partial_x^2 + \partial_y^2
\simeq
h_x^{-2} L \otimes I + h_y^{-2} I \otimes L\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(J_2\)</span> of the Jacobian corresponding to the integral
is more difficult to calculate, and since <em>all</em> of it entries are
nonzero, it will be difficult to invert. <span class="math notranslate nohighlight">\(J_1\)</span> on the other hand
is a relatively simple matrix, and can be inverted by
<a class="reference internal" href="../reference/generated/scipy.sparse.linalg.splu.html#scipy.sparse.linalg.splu" title="scipy.sparse.linalg.splu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.splu</span></code></a> (or the inverse can be approximated by
<a class="reference internal" href="../reference/generated/scipy.sparse.linalg.spilu.html#scipy.sparse.linalg.spilu" title="scipy.sparse.linalg.spilu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.spilu</span></code></a>). So we are content to take
<span class="math notranslate nohighlight">\(M\approx{}J_1^{-1}\)</span> and hope for the best.</p>
<p>In the example below, we use the preconditioner <span class="math notranslate nohighlight">\(M=J_1^{-1}\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">spdiags</span><span class="p">,</span> <span class="n">kron</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spilu</span><span class="p">,</span> <span class="n">LinearOperator</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">eye</span>

<span class="c1"># parameters</span>
<span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">75</span>
<span class="n">hx</span><span class="p">,</span> <span class="n">hy</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">P_left</span><span class="p">,</span> <span class="n">P_right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">P_top</span><span class="p">,</span> <span class="n">P_bottom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">get_preconditioner</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the preconditioner M&quot;&quot;&quot;</span>
    <span class="n">diags_x</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span>
    <span class="n">diags_x</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
    <span class="n">diags_x</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
    <span class="n">diags_x</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
    <span class="n">Lx</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">(</span><span class="n">diags_x</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">nx</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>

    <span class="n">diags_y</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
    <span class="n">diags_y</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
    <span class="n">diags_y</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
    <span class="n">diags_y</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
    <span class="n">Ly</span> <span class="o">=</span> <span class="n">spdiags</span><span class="p">(</span><span class="n">diags_y</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">ny</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>

    <span class="n">J1</span> <span class="o">=</span> <span class="n">kron</span><span class="p">(</span><span class="n">Lx</span><span class="p">,</span> <span class="n">eye</span><span class="p">(</span><span class="n">ny</span><span class="p">))</span> <span class="o">+</span> <span class="n">kron</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">Ly</span><span class="p">)</span>

    <span class="c1"># Now we have the matrix `J_1`. We need to find its inverse `M` --</span>
    <span class="c1"># however, since an approximate inverse is enough, we can use</span>
    <span class="c1"># the *incomplete LU* decomposition</span>

    <span class="n">J1_ilu</span> <span class="o">=</span> <span class="n">spilu</span><span class="p">(</span><span class="n">J1</span><span class="p">)</span>

    <span class="c1"># This returns an object with a method .solve() that evaluates</span>
    <span class="c1"># the corresponding matrix-vector product. We need to wrap it into</span>
    <span class="c1"># a LinearOperator before it can be passed to the Krylov methods:</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">LinearOperator</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">),</span> <span class="n">matvec</span><span class="o">=</span><span class="n">J1_ilu</span><span class="o">.</span><span class="n">solve</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">preconditioning</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the solution&quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
        <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">d2x</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="n">d2y</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

        <span class="n">d2x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>   <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
        <span class="n">d2x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>    <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">+</span> <span class="n">P_left</span><span class="p">)</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>
        <span class="n">d2x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">P_right</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hx</span><span class="o">/</span><span class="n">hx</span>

        <span class="n">d2y</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
        <span class="n">d2y</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>  <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    <span class="o">+</span> <span class="n">P_bottom</span><span class="p">)</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>
        <span class="n">d2y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">P_top</span>   <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">P</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">+</span> <span class="n">P</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">hy</span><span class="o">/</span><span class="n">hy</span>

        <span class="k">return</span> <span class="n">d2x</span> <span class="o">+</span> <span class="n">d2y</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># preconditioner</span>
    <span class="k">if</span> <span class="n">preconditioning</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">get_preconditioner</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># solve</span>
    <span class="n">guess</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>

    <span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">guess</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;krylov&#39;</span><span class="p">,</span>
               <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="s1">&#39;jac_options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;inner_M&#39;</span><span class="p">:</span> <span class="n">M</span><span class="p">}})</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Residual&#39;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">residual</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Evaluations&#39;</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">sol</span><span class="o">.</span><span class="n">x</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">preconditioning</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># visualize</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:(</span><span class="n">nx</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:(</span><span class="n">ny</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">)]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">pcolor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Resulting run, first without preconditioning:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">803.614</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.000257947</span>
<span class="mi">1</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">345.912</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.166755</span>
<span class="mi">2</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">139.159</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.145657</span>
<span class="mi">3</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">27.3682</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.0348109</span>
<span class="mi">4</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">1.03303</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.00128227</span>
<span class="mi">5</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.0406634</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.00139451</span>
<span class="mi">6</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.00344341</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.00645373</span>
<span class="mi">7</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.000153671</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.00179246</span>
<span class="mi">8</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">6.7424e-06</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.00173256</span>
<span class="n">Residual</span> <span class="mf">3.57078908664e-07</span>
<span class="n">Evaluations</span> <span class="mi">317</span>
</pre></div>
</div>
<p>and then with preconditioning:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">136.993</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">7.49599e-06</span>
<span class="mi">1</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">4.80983</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.00110945</span>
<span class="mi">2</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.195942</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">0.00149362</span>
<span class="mi">3</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">0.000563597</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">7.44604e-06</span>
<span class="mi">4</span><span class="p">:</span>  <span class="o">|</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span> <span class="o">=</span> <span class="mf">1.00698e-09</span><span class="p">;</span> <span class="n">step</span> <span class="mi">1</span><span class="p">;</span> <span class="n">tol</span> <span class="mf">2.87308e-12</span>
<span class="n">Residual</span> <span class="mf">9.29603061195e-11</span>
<span class="n">Evaluations</span> <span class="mi">77</span>
</pre></div>
</div>
<p>Using a preconditioner reduced the number of evaluations of the
<code class="docutils literal notranslate"><span class="pre">residual</span></code> function by a factor of <em>4</em>. For problems where the
residual is expensive to compute, good preconditioning can be crucial
— it can even decide whether the problem is solvable in practice or
not.</p>
<p>Preconditioning is an art, science, and industry. Here, we were lucky
in making a simple choice that worked reasonably well, but there is a
lot more depth to this topic than is shown here.</p>
</section>
</section>
<section id="linear-programming-linprog">
<h2><a class="toc-backref" href="#id44" role="doc-backlink">Linear programming (<a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code></a>)</a><a class="headerlink" href="#linear-programming-linprog" title="Link to this heading">#</a></h2>
<p>The function <a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code></a> can minimize a linear objective function
subject to linear equality and inequality constraints. This kind of
problem is well known as linear programming. Linear programming solves
problems of the following form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\min_x \ &amp; c^T x \\
\mbox{such that} \ &amp; A_{ub} x \leq b_{ub},\\
&amp; A_{eq} x = b_{eq},\\
&amp; l \leq x \leq u ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(x\)</span> is a vector of decision variables; <span class="math notranslate nohighlight">\(c\)</span>, <span class="math notranslate nohighlight">\(b_{ub}\)</span>,
<span class="math notranslate nohighlight">\(b_{eq}\)</span>, <span class="math notranslate nohighlight">\(l\)</span>, and <span class="math notranslate nohighlight">\(u\)</span> are vectors; and <span class="math notranslate nohighlight">\(A_{ub}\)</span> and
<span class="math notranslate nohighlight">\(A_{eq}\)</span> are matrices.</p>
<p>In this tutorial, we will try to solve a typical linear programming
problem using <a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code></a>.</p>
<section id="linear-programming-example">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">Linear programming example</a><a class="headerlink" href="#linear-programming-example" title="Link to this heading">#</a></h3>
<p>Consider the following simple linear programming problem:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\max_{x_1, x_2, x_3, x_4} \ &amp; 29x_1 + 45x_2 \\
\mbox{such that} \
&amp; x_1 -x_2 -3x_3 \leq 5\\
&amp; 2x_1 -3x_2 -7x_3 + 3x_4 \geq 10\\
&amp; 2x_1 + 8x_2 + x_3 = 60\\
&amp; 4x_1 + 4x_2 + x_4 = 60\\
&amp; 0 \leq x_0\\
&amp; 0 \leq x_1 \leq 5\\
&amp; x_2 \leq 0.5\\
&amp; -3 \leq x_3\\\end{split}\]</div>
<p>We need some mathematical manipulations to convert the target problem to the form accepted by <a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code></a>.</p>
<p>First of all, let’s consider the objective function.
We want to maximize the objective
function, but <a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code></a> can only accept a minimization problem. This is easily remedied by converting the maximize
<span class="math notranslate nohighlight">\(29x_1 + 45x_2\)</span> to minimizing <span class="math notranslate nohighlight">\(-29x_1 -45x_2\)</span>. Also, <span class="math notranslate nohighlight">\(x_3, x_4\)</span> are not shown in the objective
function. That means the weights corresponding with <span class="math notranslate nohighlight">\(x_3, x_4\)</span> are zero. So, the objective function can be
converted to:</p>
<div class="math notranslate nohighlight">
\[\min_{x_1, x_2, x_3, x_4} \ -29x_1 -45x_2 + 0x_3 + 0x_4\]</div>
<p>If we define the vector of decision variables <span class="math notranslate nohighlight">\(x = [x_1, x_2, x_3, x_4]^T\)</span>, the objective weights vector <span class="math notranslate nohighlight">\(c\)</span> of <a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code></a> in this problem
should be</p>
<div class="math notranslate nohighlight">
\[c = [-29, -45, 0, 0]^T\]</div>
<p>Next, let’s consider the two inequality constraints. The first one is a “less than” inequality, so it is already in the form accepted by <a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linprog</span></code></a>.
The second one is a “greater than” inequality, so we need to multiply both sides by <span class="math notranslate nohighlight">\(-1\)</span> to convert it to a “less than” inequality.
Explicitly showing zero coefficients, we have:</p>
<div class="math notranslate nohighlight">
\[\begin{split}x_1 -x_2 -3x_3 + 0x_4  &amp;\leq 5\\
-2x_1 + 3x_2 + 7x_3 - 3x_4 &amp;\leq -10\\\end{split}\]</div>
<p>These equations can be converted to matrix form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}A_{ub} x \leq b_{ub}\\\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
 \begin{equation*} A_{ub} =
 \begin{bmatrix} 1 &amp; -1 &amp; -3 &amp; 0 \\
                 -2 &amp; 3 &amp; 7 &amp; -3
 \end{bmatrix}
 \end{equation*}</div><div class="math notranslate nohighlight">
 \begin{equation*} b_{ub} =
 \begin{bmatrix} 5 \\
                 -10
 \end{bmatrix}
 \end{equation*}</div><p>Next, let’s consider the two equality constraints. Showing zero weights explicitly, these are:</p>
<div class="math notranslate nohighlight">
\[\begin{split}2x_1 + 8x_2 + 1x_3 + 0x_4 &amp;= 60\\
4x_1 + 4x_2 + 0x_3 + 1x_4 &amp;= 60\\\end{split}\]</div>
<p>These equations can be converted to matrix form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}A_{eq} x = b_{eq}\\\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
 \begin{equation*} A_{eq} =
 \begin{bmatrix} 2 &amp; 8 &amp; 1 &amp; 0 \\
                 4 &amp; 4 &amp; 0 &amp; 1
 \end{bmatrix}
 \end{equation*}</div><div class="math notranslate nohighlight">
 \begin{equation*} b_{eq} =
 \begin{bmatrix} 60 \\
                 60
 \end{bmatrix}
 \end{equation*}</div><p>Lastly, let’s consider the separate inequality constraints on individual decision variables, which are known as
“box constraints” or “simple bounds”. These constraints can be applied using the bounds argument of <a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code></a>.
As noted in the <a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code></a> documentation, the default value of bounds is <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">None)</span></code>, meaning that the
lower bound on each decision variable is 0, and the upper bound on each decision variable is infinity:
all the decision variables are non-negative. Our bounds are different, so we will need to specify the lower and upper bound on each
decision variable as a tuple and group these tuples into a list.</p>
<p>Finally, we can solve the transformed problem using <a class="reference internal" href="../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog" title="scipy.optimize.linprog"><code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linprog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">29.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">45.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">5.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">60.0</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># +/- np.inf can be used instead of None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x3_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0_bounds</span><span class="p">,</span> <span class="n">x1_bounds</span><span class="p">,</span> <span class="n">x2_bounds</span><span class="p">,</span> <span class="n">x3_bounds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A_ub</span><span class="o">=</span><span class="n">A_ub</span><span class="p">,</span> <span class="n">b_ub</span><span class="o">=</span><span class="n">b_ub</span><span class="p">,</span> <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span> <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
<span class="go">The problem is infeasible. (HiGHS Status 8: model_status is Infeasible; primal_status is At lower/fixed bound)</span>
</pre></div>
</div>
<p>The result states that our problem is infeasible, meaning that there is no solution vector that satisfies all the
constraints. That doesn’t necessarily mean we did anything wrong; some problems truly are infeasible.
Suppose, however, that we were to decide that our bound constraint on <span class="math notranslate nohighlight">\(x_1\)</span> was too tight and that it could be loosened
to <span class="math notranslate nohighlight">\(0 \leq x_1 \leq 6\)</span>. After adjusting our code <code class="docutils literal notranslate"><span class="pre">x1_bounds</span> <span class="pre">=</span> <span class="pre">(0,</span> <span class="pre">6)</span></code> to reflect the change and executing it again:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x1_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0_bounds</span><span class="p">,</span> <span class="n">x1_bounds</span><span class="p">,</span> <span class="n">x2_bounds</span><span class="p">,</span> <span class="n">x3_bounds</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A_ub</span><span class="o">=</span><span class="n">A_ub</span><span class="p">,</span> <span class="n">b_ub</span><span class="o">=</span><span class="n">b_ub</span><span class="p">,</span> <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span> <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
<span class="go">Optimization terminated successfully. (HiGHS Status 7: Optimal)</span>
</pre></div>
</div>
<p>The result shows the optimization was successful.
We can check the objective value (<code class="docutils literal notranslate"><span class="pre">result.fun</span></code>) is same as <span class="math notranslate nohighlight">\(c^Tx\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fun</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span> <span class="o">@</span> <span class="n">x</span><span class="p">)</span>
<span class="go">-505.97435889013434  # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="go">-505.97435889013434  # may vary</span>
</pre></div>
</div>
<p>We can also check that all constraints are satisfied within reasonable tolerances:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b_ub</span> <span class="o">-</span> <span class="p">(</span><span class="n">A_ub</span> <span class="o">@</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>  <span class="c1"># this is equivalent to result.slack</span>
<span class="go">[ 6.52747190e-10, -2.26730279e-09]  # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b_eq</span> <span class="o">-</span> <span class="p">(</span><span class="n">A_eq</span> <span class="o">@</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>  <span class="c1"># this is equivalent to result.con</span>
<span class="go">[ 9.78840831e-09, 1.04662945e-08]]  # may vary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">6.0</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">&lt;=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="go">[True, True, True, True]</span>
</pre></div>
</div>
</section>
</section>
<section id="assignment-problems">
<h2><a class="toc-backref" href="#id46" role="doc-backlink">Assignment problems</a><a class="headerlink" href="#assignment-problems" title="Link to this heading">#</a></h2>
<section id="linear-sum-assignment-problem-example">
<h3><a class="toc-backref" href="#id47" role="doc-backlink">Linear sum assignment problem example</a><a class="headerlink" href="#linear-sum-assignment-problem-example" title="Link to this heading">#</a></h3>
<p>Consider the problem of selecting students for a swimming medley relay team.
We have a table showing times for each swimming style of five students:</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Student</p></th>
<th class="head"><p>backstroke</p></th>
<th class="head"><p>breaststroke</p></th>
<th class="head"><p>butterfly</p></th>
<th class="head"><p>freestyle</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>A</p></td>
<td><p>43.5</p></td>
<td><p>47.1</p></td>
<td><p>48.4</p></td>
<td><p>38.2</p></td>
</tr>
<tr class="row-odd"><td><p>B</p></td>
<td><p>45.5</p></td>
<td><p>42.1</p></td>
<td><p>49.6</p></td>
<td><p>36.8</p></td>
</tr>
<tr class="row-even"><td><p>C</p></td>
<td><p>43.4</p></td>
<td><p>39.1</p></td>
<td><p>42.1</p></td>
<td><p>43.2</p></td>
</tr>
<tr class="row-odd"><td><p>D</p></td>
<td><p>46.5</p></td>
<td><p>44.1</p></td>
<td><p>44.5</p></td>
<td><p>41.2</p></td>
</tr>
<tr class="row-even"><td><p>E</p></td>
<td><p>46.3</p></td>
<td><p>47.8</p></td>
<td><p>50.4</p></td>
<td><p>37.2</p></td>
</tr>
</tbody>
</table>
</div>
<p>We need to choose a student for each of the four swimming styles such that
the total relay time is minimized.
This is a typical linear sum assignment problem. We can use <a class="reference internal" href="../reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment" title="scipy.optimize.linear_sum_assignment"><code class="xref py py-func docutils literal notranslate"><span class="pre">linear_sum_assignment</span></code></a> to solve it.</p>
<p>The linear sum assignment problem is one of the most famous combinatorial optimization problems.
Given a “cost matrix” <span class="math notranslate nohighlight">\(C\)</span>, the problem is to choose</p>
<ul class="simple">
<li><p>exactly one element from each row</p></li>
<li><p>without choosing more than one element from any column</p></li>
<li><p>such that the sum of the chosen elements is minimized</p></li>
</ul>
<p>In other words, we need to assign each row to one column such that the sum of
the corresponding entries is minimized.</p>
<p>Formally, let <span class="math notranslate nohighlight">\(X\)</span> be a boolean matrix where <span class="math notranslate nohighlight">\(X[i,j] = 1\)</span> iff row  <span class="math notranslate nohighlight">\(i\)</span> is assigned to column <span class="math notranslate nohighlight">\(j\)</span>.
Then the optimal assignment has cost</p>
<div class="math notranslate nohighlight">
\[\min \sum_i \sum_j C_{i,j} X_{i,j}\]</div>
<p>The first step is to define the cost matrix.
In this example, we want to assign each swimming style to a student.
<a class="reference internal" href="../reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment" title="scipy.optimize.linear_sum_assignment"><code class="xref py py-func docutils literal notranslate"><span class="pre">linear_sum_assignment</span></code></a> is able to assign each row of a cost matrix to a column.
Therefore, to form the cost matrix, the table above needs to be transposed so that the rows
correspond with swimming styles and the columns correspond with students:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">43.5</span><span class="p">,</span> <span class="mf">45.5</span><span class="p">,</span> <span class="mf">43.4</span><span class="p">,</span> <span class="mf">46.5</span><span class="p">,</span> <span class="mf">46.3</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mf">47.1</span><span class="p">,</span> <span class="mf">42.1</span><span class="p">,</span> <span class="mf">39.1</span><span class="p">,</span> <span class="mf">44.1</span><span class="p">,</span> <span class="mf">47.8</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mf">48.4</span><span class="p">,</span> <span class="mf">49.6</span><span class="p">,</span> <span class="mf">42.1</span><span class="p">,</span> <span class="mf">44.5</span><span class="p">,</span> <span class="mf">50.4</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mf">38.2</span><span class="p">,</span> <span class="mf">36.8</span><span class="p">,</span> <span class="mf">43.2</span><span class="p">,</span> <span class="mf">41.2</span><span class="p">,</span> <span class="mf">37.2</span><span class="p">]])</span>
</pre></div>
</div>
<p>We can solve the assignment problem with <a class="reference internal" href="../reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment" title="scipy.optimize.linear_sum_assignment"><code class="xref py py-func docutils literal notranslate"><span class="pre">linear_sum_assignment</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">row_ind</span></code> and <code class="docutils literal notranslate"><span class="pre">col_ind</span></code> are optimal assigned matrix indexes of the cost matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row_ind</span>
<span class="go">array([0, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">col_ind</span>
<span class="go">array([0, 2, 3, 1])</span>
</pre></div>
</div>
<p>The optimal assignment is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">styles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;backstroke&quot;</span><span class="p">,</span> <span class="s2">&quot;breaststroke&quot;</span><span class="p">,</span> <span class="s2">&quot;butterfly&quot;</span><span class="p">,</span> <span class="s2">&quot;freestyle&quot;</span><span class="p">])[</span><span class="n">row_ind</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">students</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">])[</span><span class="n">col_ind</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">styles</span><span class="p">,</span> <span class="n">students</span><span class="p">))</span>
<span class="go">{&#39;backstroke&#39;: &#39;A&#39;, &#39;breaststroke&#39;: &#39;C&#39;, &#39;butterfly&#39;: &#39;D&#39;, &#39;freestyle&#39;: &#39;B&#39;}</span>
</pre></div>
</div>
<p>The optimal total medley time is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cost</span><span class="p">[</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">163.89999999999998</span>
</pre></div>
</div>
<p>Note that this result is not the same as the sum of the minimum times for each swimming style:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">161.39999999999998</span>
</pre></div>
</div>
<p>because student “C” is the best swimmer in both “breaststroke” and “butterfly” style.
We cannot assign student “C” to both styles, so we assigned student C to the “breaststroke” style
and D to the “butterfly” style to minimize the total time.</p>
<p class="rubric">References</p>
<p>Some further reading and related software, such as Newton-Krylov <a class="reference internal" href="#kk" id="id13"><span>[KK]</span></a>,
PETSc <a class="reference internal" href="#pp" id="id14"><span>[PP]</span></a>, and PyAMG <a class="reference internal" href="#amg" id="id15"><span>[AMG]</span></a>:</p>
<div role="list" class="citation-list">
<div class="citation" id="kk" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">KK</a><span class="fn-bracket">]</span></span>
<p>D.A. Knoll and D.E. Keyes, “Jacobian-free Newton-Krylov methods”,
J. Comp. Phys. 193, 357 (2004). <a class="reference external" href="https://doi.org/10.1016/j.jcp.2003.08.010">DOI:10.1016/j.jcp.2003.08.010</a></p>
</div>
<div class="citation" id="pp" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">PP</a><span class="fn-bracket">]</span></span>
<p>PETSc <a class="reference external" href="https://www.mcs.anl.gov/petsc/">https://www.mcs.anl.gov/petsc/</a> and its Python bindings
<a class="reference external" href="https://bitbucket.org/petsc/petsc4py/">https://bitbucket.org/petsc/petsc4py/</a></p>
</div>
<div class="citation" id="amg" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">AMG</a><span class="fn-bracket">]</span></span>
<p>PyAMG (algebraic multigrid preconditioners/solvers)
<a class="github reference external" href="https://github.com/pyamg/pyamg/issues">pyamg/pyamg#issues</a></p>
</div>
</div>
</section>
</section>
<section id="mixed-integer-linear-programming">
<span id="tutorial-optimize-milp"></span><h2><a class="toc-backref" href="#id48" role="doc-backlink">Mixed integer linear programming</a><a class="headerlink" href="#mixed-integer-linear-programming" title="Link to this heading">#</a></h2>
<section id="knapsack-problem-example">
<h3><a class="toc-backref" href="#id49" role="doc-backlink">Knapsack problem example</a><a class="headerlink" href="#knapsack-problem-example" title="Link to this heading">#</a></h3>
<p>The knapsack problem is a well known combinatorial optimization problem.
Given a set of items, each with a size and a value, the problem is to choose
the items that maximize the total value under the condition that the total size
is below a certain threshold.</p>
<p>Formally, let</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x_i\)</span> be a boolean variable that indicates whether item <span class="math notranslate nohighlight">\(i\)</span> is
included in the knapsack,</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span> be the total number of items,</p></li>
<li><p><span class="math notranslate nohighlight">\(v_i\)</span> be the value of item <span class="math notranslate nohighlight">\(i\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(s_i\)</span> be the size of item <span class="math notranslate nohighlight">\(i\)</span>, and</p></li>
<li><p><span class="math notranslate nohighlight">\(C\)</span> be the capacity of the knapsack.</p></li>
</ul>
<p>Then the problem is:</p>
<div class="math notranslate nohighlight">
\[\max \sum_i^n  v_{i} x_{i}\]</div>
<div class="math notranslate nohighlight">
\[\text{subject to} \sum_i^n s_{i} x_{i} \leq C,  x_{i} \in {0, 1}\]</div>
<p>Although the objective function and inequality constraints are linear in the
<em>decision variables</em> <span class="math notranslate nohighlight">\(x_i\)</span>, this differs from a typical linear
programming problem in that the decision variables can only assume integer
values.  Specifically, our decision variables can only be <span class="math notranslate nohighlight">\(0\)</span> or
<span class="math notranslate nohighlight">\(1\)</span>, so this is known as a <em>binary integer linear program</em> (BILP). Such
a problem falls within the larger class of <em>mixed integer linear programs</em>
(MILPs), which we we can solve with <a class="reference internal" href="../reference/generated/scipy.optimize.milp.html#scipy.optimize.milp" title="scipy.optimize.milp"><code class="xref py py-func docutils literal notranslate"><span class="pre">milp</span></code></a>.</p>
<p>In our example, there are 8 items to choose from, and the size and value of
each is specified as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">21</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">52</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">22</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">53</span><span class="p">])</span>
</pre></div>
</div>
<p>We need to constrain our eight decision variables to be binary. We do so
by adding a <a class="reference internal" href="../reference/generated/scipy.optimize.Bounds.html#scipy.optimize.Bounds" title="scipy.optimize.Bounds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bounds</span></code></a>: constraint to ensure that they lie between
<span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(1\)</span>, and we apply “integrality” constraints to ensure that
they are <em>either</em> <span class="math notranslate nohighlight">\(0\)</span> <em>or</em> <span class="math notranslate nohighlight">\(1\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">Bounds</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 0 &lt;= x_i &lt;= 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># x_i are integers</span>
</pre></div>
</div>
<p>The knapsack capacity constraint is specified using <a class="reference internal" href="../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint" title="scipy.optimize.LinearConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearConstraint</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constraints</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">LinearConstraint</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">sizes</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="n">capacity</span><span class="p">)</span>
</pre></div>
</div>
<p>If we are following the usual rules of linear algebra, the input <code class="docutils literal notranslate"><span class="pre">A</span></code> should
be a  two-dimensional matrix, and the lower and upper bounds <code class="docutils literal notranslate"><span class="pre">lb</span></code> and <code class="docutils literal notranslate"><span class="pre">ub</span></code>
should be one-dimensional vectors, but <a class="reference internal" href="../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint" title="scipy.optimize.LinearConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearConstraint</span></code></a> is forgiving
as long as the inputs can be broadcast to consistent shapes.</p>
<p>Using the variables defined above, we can solve the knapsack problem using
<a class="reference internal" href="../reference/generated/scipy.optimize.milp.html#scipy.optimize.milp" title="scipy.optimize.milp"><code class="xref py py-func docutils literal notranslate"><span class="pre">milp</span></code></a>. Note that <a class="reference internal" href="../reference/generated/scipy.optimize.milp.html#scipy.optimize.milp" title="scipy.optimize.milp"><code class="xref py py-func docutils literal notranslate"><span class="pre">milp</span></code></a> minimizes the objective function, but we
want to maximize the total value, so we set <em class="xref py py-obj">c</em> to be negative of the values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">milp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">milp</span><span class="p">(</span><span class="n">c</span><span class="o">=-</span><span class="n">values</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">integrality</span><span class="o">=</span><span class="n">integrality</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s check the result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">success</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1., 1., 0., 1., 1., 1., 0., 0.])</span>
</pre></div>
</div>
<p>This means that we should select the items 1, 2, 4, 5, 6 to optimize the total
value under the size constraint. Note that this is different from we would have
obtained had we solved the <em>linear programming relaxation</em> (without integrality
constraints) and attempted to round the decision variables.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">milp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">milp</span><span class="p">(</span><span class="n">c</span><span class="o">=-</span><span class="n">values</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">integrality</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([1.        , 1.        , 1.        , 1.        ,</span>
<span class="go">       0.55882353, 1.        , 0.        , 0.        ])</span>
</pre></div>
</div>
<p>If we were to round this solution up to
<code class="docutils literal notranslate"><span class="pre">array([1.,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></code>, our knapsack would be over the
capacity constraint, whereas if we were to round down to
<code class="docutils literal notranslate"><span class="pre">array([1.,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">0.,</span> <span class="pre">1.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></code>, we would have a sub-optimal
solution.</p>
<p>For more MILP tutorials, see the Jupyter notebooks on SciPy Cookbooks:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://nbviewer.org/github/scipy/scipy-cookbook/blob/main/ipython/LinearAndMixedIntegerLinearProgramming/compressed_sensing_milp_tutorial_1.ipynb">Compressed Sensing l1 program</a></p></li>
<li><p><a class="reference external" href="https://nbviewer.org/github/scipy/scipy-cookbook/blob/main/ipython/LinearAndMixedIntegerLinearProgramming/compressed_sensing_milp_tutorial_2.ipynb">Compressed Sensing l0 program</a></p></li>
</ul>
</section>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="integrate.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Integration (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.integrate</span></code>)</p>
      </div>
    </a>
    <a class="right-next"
       href="interpolate.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Interpolation (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.interpolate</span></code>)</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#local-minimization-of-multivariate-scalar-functions-minimize">Local minimization of multivariate scalar functions (<code class="xref py py-func docutils literal notranslate"><span class="pre">minimize</span></code>)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unconstrained-minimization">Unconstrained minimization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#nelder-mead-simplex-algorithm-method-nelder-mead">Nelder-Mead Simplex algorithm (<code class="docutils literal notranslate"><span class="pre">method='Nelder-Mead'</span></code>)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#broyden-fletcher-goldfarb-shanno-algorithm-method-bfgs">Broyden-Fletcher-Goldfarb-Shanno algorithm (<code class="docutils literal notranslate"><span class="pre">method='BFGS'</span></code>)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#newton-conjugate-gradient-algorithm-method-newton-cg">Newton-Conjugate-Gradient algorithm (<code class="docutils literal notranslate"><span class="pre">method='Newton-CG'</span></code>)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#trust-region-newton-conjugate-gradient-algorithm-method-trust-ncg">Trust-Region Newton-Conjugate-Gradient Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-ncg'</span></code>)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#trust-region-truncated-generalized-lanczos-conjugate-gradient-algorithm-method-trust-krylov">Trust-Region Truncated Generalized Lanczos / Conjugate Gradient Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-krylov'</span></code>)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#trust-region-nearly-exact-algorithm-method-trust-exact">Trust-Region Nearly Exact Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-exact'</span></code>)</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#constrained-minimization">Constrained minimization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#trust-region-constrained-algorithm-method-trust-constr">Trust-Region Constrained Algorithm (<code class="docutils literal notranslate"><span class="pre">method='trust-constr'</span></code>)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#sequential-least-squares-programming-slsqp-algorithm-method-slsqp">Sequential Least SQuares Programming (SLSQP) Algorithm (<code class="docutils literal notranslate"><span class="pre">method='SLSQP'</span></code>)</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#local-minimization-solver-comparison">Local minimization solver comparison</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#global-optimization">Global optimization</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#comparison-of-global-optimizers">Comparison of Global Optimizers</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#least-squares-minimization-least-squares">Least-squares minimization (<code class="xref py py-func docutils literal notranslate"><span class="pre">least_squares</span></code>)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-of-solving-a-fitting-problem">Example of solving a fitting problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#further-examples">Further examples</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#univariate-function-minimizers-minimize-scalar">Univariate function minimizers (<code class="xref py py-func docutils literal notranslate"><span class="pre">minimize_scalar</span></code>)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unconstrained-minimization-method-brent">Unconstrained minimization (<code class="docutils literal notranslate"><span class="pre">method='brent'</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bounded-minimization-method-bounded">Bounded minimization (<code class="docutils literal notranslate"><span class="pre">method='bounded'</span></code>)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#custom-minimizers">Custom minimizers</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#root-finding">Root finding</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scalar-functions">Scalar functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fixed-point-solving">Fixed-point solving</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sets-of-equations">Sets of equations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#root-finding-for-large-problems">Root finding for large problems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#still-too-slow-preconditioning">Still too slow? Preconditioning.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#linear-programming-linprog">Linear programming (<code class="xref py py-func docutils literal notranslate"><span class="pre">linprog</span></code>)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linear-programming-example">Linear programming example</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#assignment-problems">Assignment problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linear-sum-assignment-problem-example">Linear sum assignment problem example</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mixed-integer-linear-programming">Mixed integer linear programming</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#knapsack-problem-example">Knapsack problem example</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2008-2024, The SciPy community.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.0.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>