
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Sparse eigenvalue problems with ARPACK &#8212; SciPy v1.7.0.dev0+1036.4ec6f29 Manual</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../_static/scipy.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Compressed Sparse Graph Routines (scipy.sparse.csgraph)" href="csgraph.html" />
    <link rel="prev" title="Linear Algebra (scipy.linalg)" href="linalg.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../index.html">
  <img src="../_static/scipyshiny_small.png" class="logo" alt="logo">
</a>      


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../getting_started.html">
  Getting started
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../dev/index.html">
  Development
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../release.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/scipy/scipy" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="general.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="special.html">
   Special functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.special
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="integrate.html">
   Integration (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.integrate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optimize.html">
   Optimization (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.optimize
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="interpolate.html">
   Interpolation (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.interpolate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fft.html">
   Fourier Transforms (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.fft
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="signal.html">
   Signal Processing (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.signal
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linalg.html">
   Linear Algebra (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.linalg
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Sparse eigenvalue problems with ARPACK
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="csgraph.html">
   Compressed Sparse Graph Routines (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.sparse.csgraph
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="spatial.html">
   Spatial data structures and algorithms (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.spatial
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stats.html">
   Statistics (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.stats
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ndimage.html">
   Multidimensional image processing (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.ndimage
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="io.html">
   File IO (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.io
    </span>
   </code>
   )
  </a>
 </li>
</ul>

    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#basic-functionality">
   Basic functionality
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#shift-invert-mode">
   Shift-invert mode
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#examples">
   Examples
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#use-of-linearoperator">
   Use of LinearOperator
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="sparse-eigenvalue-problems-with-arpack">
<h1>Sparse eigenvalue problems with ARPACK<a class="headerlink" href="#sparse-eigenvalue-problems-with-arpack" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>ARPACK <a class="footnote-reference brackets" href="#id3" id="id1">1</a> is a Fortran package which provides routines for quickly finding a few
eigenvalues/eigenvectors of large sparse matrices. In order to find these
solutions, it requires only left-multiplication by the matrix in question.
This operation is performed through a <em>reverse-communication</em> interface. The
result of this structure is that ARPACK is able to find eigenvalues and
eigenvectors of any linear function mapping a vector to a vector.</p>
<p>All of the functionality provided in ARPACK is contained within the two
high-level interfaces <a class="reference internal" href="../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs" title="scipy.sparse.linalg.eigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigs</span></code></a> and
<a class="reference internal" href="../reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="scipy.sparse.linalg.eigsh"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigsh</span></code></a>. <a class="reference internal" href="../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs" title="scipy.sparse.linalg.eigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigs</span></code></a>
provides interfaces for finding the
eigenvalues/vectors of real or complex nonsymmetric square matrices, while
<a class="reference internal" href="../reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="scipy.sparse.linalg.eigsh"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigsh</span></code></a> provides interfaces for real-symmetric or complex-hermitian
matrices.</p>
</section>
<section id="basic-functionality">
<h2>Basic functionality<a class="headerlink" href="#basic-functionality" title="Permalink to this headline">¶</a></h2>
<p>ARPACK can solve either standard eigenvalue problems of the form</p>
<div class="math notranslate nohighlight">
\[A \mathbf{x} = \lambda \mathbf{x}\]</div>
<p>or general eigenvalue problems of the form</p>
<div class="math notranslate nohighlight">
\[A \mathbf{x} = \lambda M \mathbf{x}.\]</div>
<p>The power of ARPACK is that it can compute only a specified subset of
eigenvalue/eigenvector pairs. This is accomplished through the keyword
<code class="docutils literal notranslate"><span class="pre">which</span></code>. The following values of <code class="docutils literal notranslate"><span class="pre">which</span></code> are available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'LM'</span></code> : Eigenvalues with largest magnitude (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>, <code class="docutils literal notranslate"><span class="pre">eigsh</span></code>),
that is, largest eigenvalues in the euclidean norm of complex numbers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'SM'</span></code> : Eigenvalues with smallest magnitude (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>, <code class="docutils literal notranslate"><span class="pre">eigsh</span></code>),
that is, smallest eigenvalues in the euclidean norm of complex numbers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'LR'</span></code> : Eigenvalues with largest real part (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'SR'</span></code> : Eigenvalues with smallest real part (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'LI'</span></code> : Eigenvalues with largest imaginary part (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'SI'</span></code> : Eigenvalues with smallest imaginary part (<code class="docutils literal notranslate"><span class="pre">eigs</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'LA'</span></code> : Eigenvalues with largest algebraic value (<code class="docutils literal notranslate"><span class="pre">eigsh</span></code>),
that is, largest eigenvalues inclusive of any negative sign.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'SA'</span></code> : Eigenvalues with smallest algebraic value (<code class="docutils literal notranslate"><span class="pre">eigsh</span></code>),
that is, smallest eigenvalues inclusive of any negative sign.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'BE'</span></code> : Eigenvalues from both ends of the spectrum (<code class="docutils literal notranslate"><span class="pre">eigsh</span></code>).</p></li>
</ul>
<p>Note that ARPACK is generally better at finding extremal eigenvalues, that
is, eigenvalues with large magnitudes. In particular, using <code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'SM'</span></code>
may lead to slow execution time and/or anomalous results. A better approach
is to use <em>shift-invert mode</em>.</p>
</section>
<section id="shift-invert-mode">
<h2>Shift-invert mode<a class="headerlink" href="#shift-invert-mode" title="Permalink to this headline">¶</a></h2>
<p>Shift-invert mode relies on the following observation. For the generalized
eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[A \mathbf{x} = \lambda M \mathbf{x},\]</div>
<p>it can be shown that</p>
<div class="math notranslate nohighlight">
\[(A - \sigma M)^{-1} M \mathbf{x} = \nu \mathbf{x},\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\nu = \frac{1}{\lambda - \sigma}.\]</div>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Imagine you’d like to find the smallest and largest eigenvalues and the
corresponding eigenvectors for a large matrix. ARPACK can handle many
forms of input: dense matrices ,such as <a class="reference external" href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.21.dev0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> instances, sparse
matrices, such as <a class="reference internal" href="../reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="scipy.sparse.csr_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a>, or a general linear operator
derived from <a class="reference internal" href="../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.LinearOperator</span></code></a>. For this example, for
simplicity, we’ll construct a symmetric, positive-definite matrix.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eig</span><span class="p">,</span> <span class="n">eigh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">eigsh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># create a symmetric matrix</span>
</pre></div>
</div>
<p>We now have a symmetric matrix <code class="docutils literal notranslate"><span class="pre">X</span></code>, with which to test the routines. First,
compute a standard eigenvalue decomposition using <code class="docutils literal notranslate"><span class="pre">eigh</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">,</span> <span class="n">evecs_all</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>As the dimension of <code class="docutils literal notranslate"><span class="pre">X</span></code> grows, this routine becomes very slow. Especially,
if only a few eigenvectors and eigenvalues are needed, <code class="docutils literal notranslate"><span class="pre">ARPACK</span></code> can be a
better option. First let’s compute the largest eigenvalues (<code class="docutils literal notranslate"><span class="pre">which</span> <span class="pre">=</span> <span class="pre">'LM'</span></code>)
of <code class="docutils literal notranslate"><span class="pre">X</span></code> and compare them to the known results:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large</span><span class="p">,</span> <span class="n">evecs_large</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">evals_all</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>
<span class="go">[29.22435321 30.05590784 30.58591252]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">evals_large</span><span class="p">)</span>
<span class="go">[29.22435321 30.05590784 30.58591252]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_large</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,</span><span class="o">-</span><span class="mi">3</span><span class="p">:]))</span>
<span class="go">array([[-1.  0.  0.],       # may vary (signs)</span>
<span class="go">       [ 0.  1.  0.],</span>
<span class="go">       [-0.  0. -1.]])</span>
</pre></div>
</div>
<p>The results are as expected. ARPACK recovers the desired eigenvalues and they
match the previously known results. Furthermore, the eigenvectors are
orthogonal, as we’d expect. Now, let’s attempt to solve for the eigenvalues
with smallest magnitude:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span><span class="p">,</span> <span class="n">evecs_small</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SM&#39;</span><span class="p">)</span>
<span class="x">Traceback (most recent call last):       # may vary (convergence)</span>
<span class="x">...</span>
<span class="x">scipy.sparse.linalg.eigen.arpack.arpack.ArpackNoConvergence:</span>
<span class="go">ARPACK error -1: No convergence (1001 iterations, 0/3 eigenvectors converged)</span>
</pre></div>
</div>
<p>Oops. We see that, as mentioned above, <code class="docutils literal notranslate"><span class="pre">ARPACK</span></code> is not quite as adept at
finding small eigenvalues. There are a few ways this problem can be
addressed. We could increase the tolerance (<code class="docutils literal notranslate"><span class="pre">tol</span></code>) to lead to faster
convergence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span><span class="p">,</span> <span class="n">evecs_small</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SM&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1E-2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([0.00053181, 0.00298319, 0.01387821])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span>
<span class="go">array([0.00053181, 0.00298319, 0.01387821])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_small</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">])</span>
<span class="go">array([[ 0.99999999  0.00000024 -0.00000049],    # may vary (signs)</span>
<span class="go">       [-0.00000023  0.99999999  0.00000056],</span>
<span class="go">       [ 0.00000031 -0.00000037  0.99999852]])</span>
</pre></div>
</div>
<p>This works, but we lose the precision in the results. Another option is
to increase the maximum number of iterations (<code class="docutils literal notranslate"><span class="pre">maxiter</span></code>) from 1000 to 5000:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span><span class="p">,</span> <span class="n">evecs_small</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;SM&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([0.00053181, 0.00298319, 0.01387821])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span>
<span class="go">array([0.00053181, 0.00298319, 0.01387821])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_small</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">])</span>
<span class="go">array([[ 1.  0.  0.],           # may vary (signs)</span>
<span class="go">       [-0.  1.  0.],</span>
<span class="go">       [ 0.  0. -1.]])</span>
</pre></div>
</div>
<p>We get the results we’d hoped for, but the computation time is much longer.
Fortunately, <code class="docutils literal notranslate"><span class="pre">ARPACK</span></code> contains a mode that allows a quick determination of
non-external eigenvalues: <em>shift-invert mode</em>. As mentioned above, this
mode involves transforming the eigenvalue problem to an equivalent problem
with different eigenvalues. In this case, we hope to find eigenvalues near
zero, so we’ll choose <code class="docutils literal notranslate"><span class="pre">sigma</span> <span class="pre">=</span> <span class="pre">0</span></code>. The transformed eigenvalues will
then satisfy <span class="math notranslate nohighlight">\(\nu = 1/(\lambda - \sigma) = 1/\lambda\)</span>, so our
small eigenvalues <span class="math notranslate nohighlight">\(\lambda\)</span> become large eigenvalues <span class="math notranslate nohighlight">\(\nu\)</span>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span><span class="p">,</span> <span class="n">evecs_small</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([0.00053181, 0.00298319, 0.01387821])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_small</span>
<span class="go">array([0.00053181, 0.00298319, 0.01387821])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_small</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">])</span>
<span class="go">array([[ 1.  0.  0.],    # may vary (signs)</span>
<span class="go">       [ 0. -1. -0.],</span>
<span class="go">       [-0. -0.  1.]])</span>
</pre></div>
</div>
<p>We get the results we were hoping for, with much less computational time.
Note that the transformation from <span class="math notranslate nohighlight">\(\nu \to \lambda\)</span> takes place
entirely in the background. The user need not worry about the details.</p>
<p>The shift-invert mode provides more than just a fast way to obtain a few
small eigenvalues. Say, you
desire to find internal eigenvalues and eigenvectors, e.g., those nearest to
<span class="math notranslate nohighlight">\(\lambda = 1\)</span>. Simply set <code class="docutils literal notranslate"><span class="pre">sigma</span> <span class="pre">=</span> <span class="pre">1</span></code> and ARPACK will take care of
the rest:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_mid</span><span class="p">,</span> <span class="n">evecs_mid</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">evals_all</span><span class="p">)))[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">[</span><span class="n">i_sort</span><span class="p">]</span>
<span class="go">array([0.94164107, 1.05464515, 0.99090277])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_mid</span>
<span class="go">array([0.94164107, 0.99090277, 1.05464515])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_mid</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,</span><span class="n">i_sort</span><span class="p">]))</span>
<span class="go">array([[-0.  1.  0.],     # may vary (signs)</span>
<span class="go">       [-0. -0.  1.],</span>
<span class="go">       [ 1.  0.  0.]]</span>
</pre></div>
</div>
<p>The eigenvalues come out in a different order, but they’re all there.
Note that the shift-invert mode requires the internal solution of a matrix
inverse. This is taken care of automatically by <code class="docutils literal notranslate"><span class="pre">eigsh</span></code> and <a class="reference internal" href="../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs" title="scipy.sparse.linalg.eigs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigs</span></code></a>,
but the operation can also be specified by the user. See the docstring of
<a class="reference internal" href="../reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="scipy.sparse.linalg.eigsh"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigsh</span></code></a> and
<a class="reference internal" href="../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs" title="scipy.sparse.linalg.eigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigs</span></code></a> for details.</p>
</section>
<section id="use-of-linearoperator">
<h2>Use of LinearOperator<a class="headerlink" href="#use-of-linearoperator" title="Permalink to this headline">¶</a></h2>
<p>We consider now the case where you’d like to avoid creating a dense matrix
and use <a class="reference internal" href="../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.LinearOperator</span></code></a> instead. Our first
linear operator applies element-wise multiplication between the input vector
and a vector <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> provided by the user to the operator itself.
This operator mimics a diagonal matrix with the elements of <span class="math notranslate nohighlight">\(\mathbf{d}\)</span>
along the main diagonal and it has the main benefit that the forward and
adjoint operations are simple element-wise multiplications other
than matrix-vector multiplications. For a diagonal matrix, we expect the
eigenvalues to be equal to the elements along the main diagonal, in this case
<span class="math notranslate nohighlight">\(\mathbf{d}\)</span>. The eigenvalues and eigenvectors obtained with <code class="docutils literal notranslate"><span class="pre">eigsh</span></code>
are compared to those obtained by using <code class="docutils literal notranslate"><span class="pre">eigh</span></code> when applied to
the dense matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">LinearOperator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Diagonal</span><span class="p">(</span><span class="n">LinearOperator</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">diag</span> <span class="o">=</span> <span class="n">diag</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="p">))</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_matvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="o">*</span><span class="n">x</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_rmatvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">diag</span><span class="o">*</span><span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dop</span> <span class="o">=</span> <span class="n">Diagonal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">,</span> <span class="n">evecs_all</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large</span><span class="p">,</span> <span class="n">evecs_large</span> <span class="o">=</span> <span class="n">eigsh</span><span class="p">(</span><span class="n">Dop</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LA&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mf">1e3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
<span class="go">array([1.53092498, 1.77243671, 2.00582508])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large</span>
<span class="go">array([1.53092498, 1.77243671, 2.00582508])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs_large</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">evecs_all</span><span class="p">[:,</span><span class="o">-</span><span class="mi">3</span><span class="p">:]))</span>
<span class="go">array([[-1.  0.  0.],     # may vary (signs)</span>
<span class="go">       [-0. -1.  0.],</span>
<span class="go">       [ 0.  0. -1.]]</span>
</pre></div>
</div>
<p>In this case, we have created a quick and easy <code class="docutils literal notranslate"><span class="pre">Diagonal</span></code> operator.
The external library <a class="reference external" href="https://pylops.readthedocs.io">PyLops</a> provides
similar capabilities in the <a class="reference external" href="https://pylops.readthedocs.io/en/latest/api/generated/pylops.Diagonal.html#pylops.Diagonal">Diagonal</a> operator,
as well as several other operators.</p>
<p>Finally, we consider a linear operator that mimics the application of a
first-derivative stencil. In this case, the operator is equivalent to a real
nonsymmetric matrix. Once again, we compare the estimated eigenvalues
and eigenvectors with those from a dense matrix that applies the
same first derivative to an input signal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">FirstDerivative</span><span class="p">(</span><span class="n">LinearOperator</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_matvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">y</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_rmatvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span>        <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">21</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># take away edge effects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dop</span> <span class="o">=</span> <span class="n">FirstDerivative</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all</span><span class="p">,</span> <span class="n">evecs_all</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large</span><span class="p">,</span> <span class="n">evecs_large</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="n">Dop</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LI&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all_imag</span> <span class="o">=</span> <span class="n">evals_all</span><span class="o">.</span><span class="n">imag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isort_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evals_all_imag</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all_imag</span> <span class="o">=</span> <span class="n">evals_all_imag</span><span class="p">[</span><span class="n">isort_imag</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large_imag</span> <span class="o">=</span> <span class="n">evals_large</span><span class="o">.</span><span class="n">imag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isort_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evals_large_imag</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large_imag</span> <span class="o">=</span> <span class="n">evals_large_imag</span><span class="p">[</span><span class="n">isort_imag</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_all_imag</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
<span class="go">array([-0.95105652, 0.95105652, -0.98768834, 0.98768834])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals_large_imag</span>
<span class="go">array([0.95105652, -0.95105652, 0.98768834, -0.98768834])</span>
</pre></div>
</div>
<p>Note that the eigenvalues of this operator are all imaginary. Moreover,
the keyword <code class="docutils literal notranslate"><span class="pre">which='LI'</span></code> of <a class="reference internal" href="../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs" title="scipy.sparse.linalg.eigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigs</span></code></a> produces
the eigenvalues with largest absolute imaginary part (both
positive and negative). Again, a more advanced implementation of the
first-derivative operator is available in the
<a class="reference external" href="https://pylops.readthedocs.io">PyLops</a> library under the name of
<a class="reference external" href="https://pylops.readthedocs.io/en/latest/api/generated/pylops.FirstDerivative.html">FirstDerivative</a>
operator.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><a class="reference external" href="http://www.caam.rice.edu/software/ARPACK/">http://www.caam.rice.edu/software/ARPACK/</a></p>
</dd>
</dl>
</section>
</section>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="linalg.html" title="previous page">Linear Algebra (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg</span></code>)</a>
    <a class='right-next' id="next-link" href="csgraph.html" title="next page">Compressed Sparse Graph Routines (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csgraph</span></code>)</a>

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2008-2021, The SciPy community.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.2.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>