
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Linear Algebra (scipy.linalg) &#8212; SciPy v1.7.0.dev0+1036.4ec6f29 Manual</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../_static/scipy.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Sparse eigenvalue problems with ARPACK" href="arpack.html" />
    <link rel="prev" title="Signal Processing (scipy.signal)" href="signal.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../index.html">
  <img src="../_static/scipyshiny_small.png" class="logo" alt="logo">
</a>      


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../getting_started.html">
  Getting started
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../dev/index.html">
  Development
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../release.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/scipy/scipy" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="general.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="special.html">
   Special functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.special
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="integrate.html">
   Integration (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.integrate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optimize.html">
   Optimization (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.optimize
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="interpolate.html">
   Interpolation (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.interpolate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fft.html">
   Fourier Transforms (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.fft
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="signal.html">
   Signal Processing (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.signal
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Linear Algebra (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.linalg
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="arpack.html">
   Sparse eigenvalue problems with ARPACK
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="csgraph.html">
   Compressed Sparse Graph Routines (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.sparse.csgraph
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="spatial.html">
   Spatial data structures and algorithms (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.spatial
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stats.html">
   Statistics (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.stats
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ndimage.html">
   Multidimensional image processing (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.ndimage
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="io.html">
   File IO (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.io
    </span>
   </code>
   )
  </a>
 </li>
</ul>

    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#scipy-linalg-vs-numpy-linalg">
   scipy.linalg vs numpy.linalg
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#numpy-matrix-vs-2-d-numpy-ndarray">
   numpy.matrix vs 2-D numpy.ndarray
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#basic-routines">
   Basic routines
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finding-the-inverse">
     Finding the inverse
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#solving-a-linear-system">
     Solving a linear system
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finding-the-determinant">
     Finding the determinant
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#computing-norms">
     Computing norms
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#solving-linear-least-squares-problems-and-pseudo-inverses">
     Solving linear least-squares problems and pseudo-inverses
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#generalized-inverse">
     Generalized inverse
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#decompositions">
   Decompositions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#eigenvalues-and-eigenvectors">
     Eigenvalues and eigenvectors
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#singular-value-decomposition">
     Singular value decomposition
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lu-decomposition">
     LU decomposition
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cholesky-decomposition">
     Cholesky decomposition
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#qr-decomposition">
     QR decomposition
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#schur-decomposition">
     Schur decomposition
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#interpolative-decomposition">
     Interpolative decomposition
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#matrix-functions">
   Matrix functions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exponential-and-logarithm-functions">
     Exponential and logarithm functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#trigonometric-functions">
     Trigonometric functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hyperbolic-trigonometric-functions">
     Hyperbolic trigonometric functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#arbitrary-function">
     Arbitrary function
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#special-matrices">
   Special matrices
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="linear-algebra-scipy-linalg">
<h1>Linear Algebra (<a class="reference internal" href="../reference/linalg.html#module-scipy.linalg" title="scipy.linalg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg</span></code></a>)<a class="headerlink" href="#linear-algebra-scipy-linalg" title="Permalink to this headline">¶</a></h1>
<p>When SciPy is built using the optimized ATLAS LAPACK and BLAS
libraries, it has very fast linear algebra capabilities. If you dig
deep enough, all of the raw LAPACK and BLAS libraries are available
for your use for even more speed. In this section, some easier-to-use
interfaces to these routines are described.</p>
<p>All of these linear algebra routines expect an object that can be
converted into a 2-D array. The output of these routines is
also a 2-D array.</p>
<section id="scipy-linalg-vs-numpy-linalg">
<h2>scipy.linalg vs numpy.linalg<a class="headerlink" href="#scipy-linalg-vs-numpy-linalg" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../reference/linalg.html#module-scipy.linalg" title="scipy.linalg"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.linalg</span></code></a> contains all the functions in
<a class="reference external" href="https://www.numpy.org/devdocs/reference/routines.linalg.html">numpy.linalg</a>.
plus some other more advanced ones not contained in <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code>.</p>
<p>Another advantage of using <code class="docutils literal notranslate"><span class="pre">scipy.linalg</span></code> over <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code> is that
it is always compiled with BLAS/LAPACK support, while for numpy this is
optional. Therefore, the scipy version might be faster depending on how
numpy was installed.</p>
<p>Therefore, unless you don’t want to add <code class="docutils literal notranslate"><span class="pre">scipy</span></code> as a dependency to
your <code class="docutils literal notranslate"><span class="pre">numpy</span></code> program, use <code class="docutils literal notranslate"><span class="pre">scipy.linalg</span></code> instead of <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code>.</p>
</section>
<section id="numpy-matrix-vs-2-d-numpy-ndarray">
<h2>numpy.matrix vs 2-D numpy.ndarray<a class="headerlink" href="#numpy-matrix-vs-2-d-numpy-ndarray" title="Permalink to this headline">¶</a></h2>
<p>The classes that represent matrices, and basic operations, such as
matrix multiplications and transpose are a part of <code class="docutils literal notranslate"><span class="pre">numpy</span></code>.
For convenience, we summarize the differences between <a class="reference external" href="https://numpy.org/devdocs/reference/generated/numpy.matrix.html#numpy.matrix" title="(in NumPy v1.21.dev0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.matrix</span></code></a>
and <a class="reference external" href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.21.dev0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> here.</p>
<p><code class="docutils literal notranslate"><span class="pre">numpy.matrix</span></code> is matrix class that has a more convenient interface
than <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> for matrix operations. This class supports, for
example, MATLAB-like creation syntax via the semicolon, has matrix
multiplication as default for the <code class="docutils literal notranslate"><span class="pre">*</span></code> operator, and contains <code class="docutils literal notranslate"><span class="pre">I</span></code>
and <code class="docutils literal notranslate"><span class="pre">T</span></code> members that serve as shortcuts for inverse and transpose:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;[1 2;3 4]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">I</span>
<span class="go">matrix([[-2. ,  1. ],</span>
<span class="go">        [ 1.5, -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;[5 6]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">matrix([[5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">T</span>
<span class="go">matrix([[5],</span>
<span class="go">        [6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">*</span><span class="n">b</span><span class="o">.</span><span class="n">T</span>
<span class="go">matrix([[17],</span>
<span class="go">        [39]])</span>
</pre></div>
</div>
<p>Despite its convenience, the use of the <code class="docutils literal notranslate"><span class="pre">numpy.matrix</span></code> class is
discouraged, since it adds nothing that cannot be accomplished
with 2-D <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> objects, and may lead to a confusion of which class
is being used. For example, the above code can be rewritten as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 2],</span>
<span class="go">      [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[-2. ,  1. ],</span>
<span class="go">      [ 1.5, -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span> <span class="c1">#2D array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([[5],</span>
<span class="go">      [6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">*</span><span class="n">b</span> <span class="c1">#not matrix multiplication!</span>
<span class="go">array([[ 5, 12],</span>
<span class="go">      [15, 24]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1">#matrix multiplication</span>
<span class="go">array([[17],</span>
<span class="go">      [39]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span> <span class="c1">#1D array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">T</span>  <span class="c1">#not matrix transpose!</span>
<span class="go">array([5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1">#does not matter for multiplication</span>
<span class="go">array([17, 39])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">scipy.linalg</span></code> operations can be applied equally to
<code class="docutils literal notranslate"><span class="pre">numpy.matrix</span></code> or to 2D <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> objects.</p>
</section>
<section id="basic-routines">
<h2>Basic routines<a class="headerlink" href="#basic-routines" title="Permalink to this headline">¶</a></h2>
<section id="finding-the-inverse">
<h3>Finding the inverse<a class="headerlink" href="#finding-the-inverse" title="Permalink to this headline">¶</a></h3>
<p>The inverse of a matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is the matrix
<span class="math notranslate nohighlight">\(\mathbf{B}\)</span>, such that <span class="math notranslate nohighlight">\(\mathbf{AB}=\mathbf{I}\)</span>, where
<span class="math notranslate nohighlight">\(\mathbf{I}\)</span> is the identity matrix consisting of ones down the
main diagonal.  Usually, <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> is denoted
<span class="math notranslate nohighlight">\(\mathbf{B}=\mathbf{A}^{-1}\)</span> . In SciPy, the matrix inverse of
the NumPy array, A, is obtained using <a class="reference internal" href="../reference/generated/scipy.linalg.inv.html#scipy.linalg.inv" title="scipy.linalg.inv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.inv</span></code></a> <code class="docutils literal notranslate"><span class="pre">(A)</span></code>, or
using <code class="docutils literal notranslate"><span class="pre">A.I</span></code> if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a Matrix. For example, let</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A} = \left[\begin{array}{ccc} 1 &amp; 3 &amp; 5\\ 2 &amp; 5 &amp; 1\\ 2 &amp; 3 &amp; 8\end{array}\right],\end{split}\]</div>
<p>then</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A^{-1}} = \frac{1}{25}
    \left[\begin{array}{ccc} -37 &amp; 9 &amp; 22 \\
                              14 &amp; 2 &amp; -9 \\
                              4 &amp; -3 &amp; 1
          \end{array}\right] = %
     \left[\begin{array}{ccc} -1.48 &amp; 0.36 &amp; 0.88  \\
                               0.56 &amp; 0.08 &amp; -0.36 \\
                               0.16 &amp; -0.12 &amp; 0.04
           \end{array}\right].\end{split}\]</div>
<p>The following example demonstrates this computation in SciPy</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 3, 5],</span>
<span class="go">      [2, 5, 1],</span>
<span class="go">      [2, 3, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[-1.48,  0.36,  0.88],</span>
<span class="go">      [ 0.56,  0.08, -0.36],</span>
<span class="go">      [ 0.16, -0.12,  0.04]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="c1">#double check</span>
<span class="go">array([[  1.00000000e+00,  -1.11022302e-16,  -5.55111512e-17],</span>
<span class="go">      [  3.05311332e-16,   1.00000000e+00,   1.87350135e-16],</span>
<span class="go">      [  2.22044605e-16,  -1.11022302e-16,   1.00000000e+00]])</span>
</pre></div>
</div>
</section>
<section id="solving-a-linear-system">
<h3>Solving a linear system<a class="headerlink" href="#solving-a-linear-system" title="Permalink to this headline">¶</a></h3>
<p>Solving linear systems of equations is straightforward using the scipy
command <a class="reference internal" href="../reference/generated/scipy.linalg.solve.html#scipy.linalg.solve" title="scipy.linalg.solve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.solve</span></code></a>. This command expects an input matrix and
a right-hand side vector. The solution vector is then computed. An
option for entering a symmetric matrix is offered, which can speed up
the processing when applicable. As an example, suppose it is desired
to solve the following simultaneous equations:</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} x + 3y + 5z &amp; = &amp; 10 \\
                   2x + 5y + z &amp; = &amp; 8  \\
                   2x + 3y + 8z &amp; = &amp; 3
 \end{eqnarray*}</div><p>We could find the solution vector using a matrix inverse:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{array}{c} x\\ y\\ z\end{array}\right]=\left[\begin{array}{ccc} 1 &amp; 3 &amp; 5\\ 2 &amp; 5 &amp; 1\\ 2 &amp; 3 &amp; 8\end{array}\right]^{-1}\left[\begin{array}{c} 10\\ 8\\ 3\end{array}\right]=\frac{1}{25}\left[\begin{array}{c} -232\\ 129\\ 19\end{array}\right]=\left[\begin{array}{c} -9.28\\ 5.16\\ 0.76\end{array}\right].\end{split}\]</div>
<p>However, it is better to use the linalg.solve command, which can be
faster and more numerically stable. In this case, it, however, gives the
same answer as shown in the following example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 2],</span>
<span class="go">      [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[5],</span>
<span class="go">      [6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># slow</span>
<span class="go">array([[-4. ],</span>
<span class="go">      [ 4.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="o">-</span> <span class="n">b</span>  <span class="c1"># check</span>
<span class="go">array([[  8.88178420e-16],</span>
<span class="go">      [  2.66453526e-15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># fast</span>
<span class="go">array([[-4. ],</span>
<span class="go">      [ 4.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="o">-</span> <span class="n">b</span>  <span class="c1"># check</span>
<span class="go">array([[ 0.],</span>
<span class="go">      [ 0.]])</span>
</pre></div>
</div>
</section>
<section id="finding-the-determinant">
<h3>Finding the determinant<a class="headerlink" href="#finding-the-determinant" title="Permalink to this headline">¶</a></h3>
<p>The determinant of a square matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is often denoted
<span class="math notranslate nohighlight">\(\left|\mathbf{A}\right|\)</span> and is a quantity often used in linear
algebra. Suppose <span class="math notranslate nohighlight">\(a_{ij}\)</span> are the elements of the matrix
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and let <span class="math notranslate nohighlight">\(M_{ij}=\left|\mathbf{A}_{ij}\right|\)</span>
be the determinant of the matrix left by removing the
<span class="math notranslate nohighlight">\(i^{\textrm{th}}\)</span> row and <span class="math notranslate nohighlight">\(j^{\textrm{th}}\)</span> column from
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span> . Then, for any row <span class="math notranslate nohighlight">\(i,\)</span></p>
<div class="math notranslate nohighlight">
\[\left|\mathbf{A}\right|=\sum_{j}\left(-1\right)^{i+j}a_{ij}M_{ij}.\]</div>
<p>This is a recursive way to define the determinant, where the base case
is defined by accepting that the determinant of a <span class="math notranslate nohighlight">\(1\times1\)</span> matrix is the only matrix element. In SciPy the determinant can be
calculated with <a class="reference internal" href="../reference/generated/scipy.linalg.det.html#scipy.linalg.det" title="scipy.linalg.det"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.det</span></code></a>. For example, the determinant of</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A=}\left[\begin{array}{ccc} 1 &amp; 3 &amp; 5\\ 2 &amp; 5 &amp; 1\\ 2 &amp; 3 &amp; 8\end{array}\right]\end{split}\]</div>
<p>is</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \left|\mathbf{A}\right| &amp; = &amp; 1\left|\begin{array}{cc} 5 &amp; 1\\ 3 &amp; 8\end{array}\right|-3\left|\begin{array}{cc} 2 &amp; 1\\ 2 &amp; 8\end{array}\right|+5\left|\begin{array}{cc} 2 &amp; 5\\ 2 &amp; 3\end{array}\right|\\  &amp; = &amp; 1\left(5\cdot8-3\cdot1\right)-3\left(2\cdot8-2\cdot1\right)+5\left(2\cdot3-2\cdot5\right)=-25.\end{eqnarray*}.</div><p>In SciPy, this is computed as shown in this example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 2],</span>
<span class="go">      [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">-2.0</span>
</pre></div>
</div>
</section>
<section id="computing-norms">
<h3>Computing norms<a class="headerlink" href="#computing-norms" title="Permalink to this headline">¶</a></h3>
<p>Matrix and vector norms can also be computed with SciPy. A wide range
of norm definitions are available using different parameters to the
order argument of <a class="reference internal" href="../reference/generated/scipy.linalg.norm.html#scipy.linalg.norm" title="scipy.linalg.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.norm</span></code></a>. This function takes a rank-1
(vectors) or a rank-2 (matrices) array and an optional order argument
(default is 2). Based on these inputs, a vector or matrix norm of the
requested order is computed.</p>
<p>For vector <em>x</em>, the order parameter can be any real number including
<code class="docutils literal notranslate"><span class="pre">inf</span></code> or <code class="docutils literal notranslate"><span class="pre">-inf</span></code>. The computed norm is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left\Vert \mathbf{x}\right\Vert =\left\{ \begin{array}{cc} \max\left|x_{i}\right| &amp; \textrm{ord}=\textrm{inf}\\ \min\left|x_{i}\right| &amp; \textrm{ord}=-\textrm{inf}\\ \left(\sum_{i}\left|x_{i}\right|^{\textrm{ord}}\right)^{1/\textrm{ord}} &amp; \left|\textrm{ord}\right|&lt;\infty.\end{array}\right.\end{split}\]</div>
<p>For matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, the only valid values for norm are <span class="math notranslate nohighlight">\(\pm2,\pm1,\)</span> <span class="math notranslate nohighlight">\(\pm\)</span> inf, and ‘fro’ (or ‘f’) Thus,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left\Vert \mathbf{A}\right\Vert =\left\{ \begin{array}{cc} \max_{i}\sum_{j}\left|a_{ij}\right| &amp; \textrm{ord}=\textrm{inf}\\ \min_{i}\sum_{j}\left|a_{ij}\right| &amp; \textrm{ord}=-\textrm{inf}\\ \max_{j}\sum_{i}\left|a_{ij}\right| &amp; \textrm{ord}=1\\ \min_{j}\sum_{i}\left|a_{ij}\right| &amp; \textrm{ord}=-1\\ \max\sigma_{i} &amp; \textrm{ord}=2\\ \min\sigma_{i} &amp; \textrm{ord}=-2\\ \sqrt{\textrm{trace}\left(\mathbf{A}^{H}\mathbf{A}\right)} &amp; \textrm{ord}=\textrm{'fro'}\end{array}\right.\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma_{i}\)</span> are the singular values of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 2],</span>
<span class="go">      [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">5.4772255750516612</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="s1">&#39;fro&#39;</span><span class="p">)</span> <span class="c1"># frobenius norm is the default</span>
<span class="go">5.4772255750516612</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># L1 norm (max column sum)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="c1"># L inf norm (max row sum)</span>
<span class="go">7</span>
</pre></div>
</div>
</section>
<section id="solving-linear-least-squares-problems-and-pseudo-inverses">
<h3>Solving linear least-squares problems and pseudo-inverses<a class="headerlink" href="#solving-linear-least-squares-problems-and-pseudo-inverses" title="Permalink to this headline">¶</a></h3>
<p>Linear least-squares problems occur in many branches of applied
mathematics. In this problem, a set of linear scaling coefficients is
sought that allows a model to fit the data. In particular, it is assumed
that data <span class="math notranslate nohighlight">\(y_{i}\)</span> is related to data <span class="math notranslate nohighlight">\(\mathbf{x}_{i}\)</span>
through a set of coefficients <span class="math notranslate nohighlight">\(c_{j}\)</span> and model functions
<span class="math notranslate nohighlight">\(f_{j}\left(\mathbf{x}_{i}\right)\)</span> via the model</p>
<div class="math notranslate nohighlight">
\[y_{i}=\sum_{j}c_{j}f_{j}\left(\mathbf{x}_{i}\right)+\epsilon_{i},\]</div>
<p>where <span class="math notranslate nohighlight">\(\epsilon_{i}\)</span> represents uncertainty in the data. The
strategy of least squares is to pick the coefficients <span class="math notranslate nohighlight">\(c_{j}\)</span> to
minimize</p>
<div class="math notranslate nohighlight">
\[J\left(\mathbf{c}\right)=\sum_{i}\left|y_{i}-\sum_{j}c_{j}f_{j}\left(x_{i}\right)\right|^{2}.\]</div>
<p>Theoretically, a global minimum will occur when</p>
<div class="math notranslate nohighlight">
\[\frac{\partial J}{\partial c_{n}^{*}}=0=\sum_{i}\left(y_{i}-\sum_{j}c_{j}f_{j}\left(x_{i}\right)\right)\left(-f_{n}^{*}\left(x_{i}\right)\right)\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \sum_{j}c_{j}\sum_{i}f_{j}\left(x_{i}\right)f_{n}^{*}\left(x_{i}\right) &amp; = &amp; \sum_{i}y_{i}f_{n}^{*}\left(x_{i}\right)\\ \mathbf{A}^{H}\mathbf{Ac} &amp; = &amp; \mathbf{A}^{H}\mathbf{y}\end{eqnarray*},</div><p>where</p>
<div class="math notranslate nohighlight">
\[\left\{ \mathbf{A}\right\} _{ij}=f_{j}\left(x_{i}\right).\]</div>
<p>When <span class="math notranslate nohighlight">\(\mathbf{A^{H}A}\)</span> is invertible, then</p>
<div class="math notranslate nohighlight">
\[\mathbf{c}=\left(\mathbf{A}^{H}\mathbf{A}\right)^{-1}\mathbf{A}^{H}\mathbf{y}=\mathbf{A}^{\dagger}\mathbf{y},\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{A}^{\dagger}\)</span> is called the pseudo-inverse of
<span class="math notranslate nohighlight">\(\mathbf{A}.\)</span> Notice that using this definition of
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span> the model can be written</p>
<div class="math notranslate nohighlight">
\[\mathbf{y}=\mathbf{Ac}+\boldsymbol{\epsilon}.\]</div>
<p>The command <a class="reference internal" href="../reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq" title="scipy.linalg.lstsq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.lstsq</span></code></a> will solve the linear least-squares
problem for <span class="math notranslate nohighlight">\(\mathbf{c}\)</span> given <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{y}\)</span> . In addition, <a class="reference internal" href="../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv" title="scipy.linalg.pinv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.pinv</span></code></a> or
<a class="reference internal" href="../reference/generated/scipy.linalg.pinv2.html#scipy.linalg.pinv2" title="scipy.linalg.pinv2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.pinv2</span></code></a> (uses a different method based on singular value
decomposition) will find <span class="math notranslate nohighlight">\(\mathbf{A}^{\dagger}\)</span> given
<span class="math notranslate nohighlight">\(\mathbf{A}.\)</span></p>
<p>The following example and figure demonstrate the use of
<a class="reference internal" href="../reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq" title="scipy.linalg.lstsq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.lstsq</span></code></a> and <a class="reference internal" href="../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv" title="scipy.linalg.pinv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.pinv</span></code></a> for solving a data-fitting
problem. The data shown below were generated using the model:</p>
<div class="math notranslate nohighlight">
\[y_{i}=c_{1}e^{-x_{i}}+c_{2}x_{i},\]</div>
<p>where <span class="math notranslate nohighlight">\(x_{i}=0.1i\)</span> for <span class="math notranslate nohighlight">\(i=1\ldots10\)</span> , <span class="math notranslate nohighlight">\(c_{1}=5\)</span>,
and <span class="math notranslate nohighlight">\(c_{2}=4.\)</span> Noise is added to <span class="math notranslate nohighlight">\(y_{i}\)</span> and the
coefficients <span class="math notranslate nohighlight">\(c_{1}\)</span> and <span class="math notranslate nohighlight">\(c_{2}\)</span> are estimated using
linear least squares.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yi</span> <span class="o">=</span> <span class="n">c1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xi</span><span class="p">)</span> <span class="o">+</span> <span class="n">c2</span><span class="o">*</span><span class="n">xi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zi</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">+</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">yi</span><span class="p">)</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xi</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">xi</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mf">0.1</span><span class="p">:</span><span class="mf">1.0</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yi2</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xi2</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">xi2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">zi</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">xi2</span><span class="p">,</span><span class="n">yi2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">5.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$x_i$&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Data fitting with linalg.lstsq&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/linalg-1.png" class="plot-directive" src="../_images/linalg-1.png" />
</figure>
</section>
<section id="generalized-inverse">
<h3>Generalized inverse<a class="headerlink" href="#generalized-inverse" title="Permalink to this headline">¶</a></h3>
<p>The generalized inverse is calculated using the command
<a class="reference internal" href="../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv" title="scipy.linalg.pinv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.pinv</span></code></a> or <a class="reference internal" href="../reference/generated/scipy.linalg.pinv2.html#scipy.linalg.pinv2" title="scipy.linalg.pinv2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.pinv2</span></code></a>. These two commands differ
in how they compute the generalized inverse. The first uses the
linalg.lstsq algorithm, while the second uses singular value
decomposition. Let <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> be an <span class="math notranslate nohighlight">\(M\times N\)</span> matrix,
then if <span class="math notranslate nohighlight">\(M&gt;N\)</span>, the generalized inverse is</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}^{\dagger}=\left(\mathbf{A}^{H}\mathbf{A}\right)^{-1}\mathbf{A}^{H},\]</div>
<p>while if <span class="math notranslate nohighlight">\(M&lt;N\)</span> matrix, the generalized inverse is</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}^{\#}=\mathbf{A}^{H}\left(\mathbf{A}\mathbf{A}^{H}\right)^{-1}.\]</div>
<p>In the case that <span class="math notranslate nohighlight">\(M=N\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}^{\dagger}=\mathbf{A}^{\#}=\mathbf{A}^{-1},\]</div>
<p>as long as <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is invertible.</p>
</section>
</section>
<section id="decompositions">
<h2>Decompositions<a class="headerlink" href="#decompositions" title="Permalink to this headline">¶</a></h2>
<p>In many applications, it is useful to decompose a matrix using other
representations. There are several decompositions supported by SciPy.</p>
<section id="eigenvalues-and-eigenvectors">
<h3>Eigenvalues and eigenvectors<a class="headerlink" href="#eigenvalues-and-eigenvectors" title="Permalink to this headline">¶</a></h3>
<p>The eigenvalue-eigenvector problem is one of the most commonly
employed linear algebra operations. In one popular form, the
eigenvalue-eigenvector problem is to find for some square matrix
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span> scalars <span class="math notranslate nohighlight">\(\lambda\)</span> and corresponding vectors
<span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, such that</p>
<div class="math notranslate nohighlight">
\[\mathbf{Av}=\lambda\mathbf{v}.\]</div>
<p>For an <span class="math notranslate nohighlight">\(N\times N\)</span> matrix, there are <span class="math notranslate nohighlight">\(N\)</span> (not necessarily
distinct) eigenvalues — roots of the (characteristic) polynomial</p>
<div class="math notranslate nohighlight">
\[\left|\mathbf{A}-\lambda\mathbf{I}\right|=0.\]</div>
<p>The eigenvectors, <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, are also sometimes called right
eigenvectors to distinguish them from another set of left eigenvectors
that satisfy</p>
<div class="math notranslate nohighlight">
\[\mathbf{v}_{L}^{H}\mathbf{A}=\lambda\mathbf{v}_{L}^{H}\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}^{H}\mathbf{v}_{L}=\lambda^{*}\mathbf{v}_{L}.\]</div>
<p>With its default optional arguments, the command <a class="reference internal" href="../reference/generated/scipy.linalg.eig.html#scipy.linalg.eig" title="scipy.linalg.eig"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.eig</span></code></a>
returns <span class="math notranslate nohighlight">\(\lambda\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}.\)</span> However, it can also
return <span class="math notranslate nohighlight">\(\mathbf{v}_{L}\)</span> and just <span class="math notranslate nohighlight">\(\lambda\)</span> by itself (
<a class="reference internal" href="../reference/generated/scipy.linalg.eigvals.html#scipy.linalg.eigvals" title="scipy.linalg.eigvals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.eigvals</span></code></a> returns just <span class="math notranslate nohighlight">\(\lambda\)</span> as well).</p>
<p>In addition, <a class="reference internal" href="../reference/generated/scipy.linalg.eig.html#scipy.linalg.eig" title="scipy.linalg.eig"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.eig</span></code></a> can also solve the more general eigenvalue problem</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \mathbf{Av} &amp; = &amp; \lambda\mathbf{Bv}\\ \mathbf{A}^{H}\mathbf{v}_{L} &amp; = &amp; \lambda^{*}\mathbf{B}^{H}\mathbf{v}_{L}\end{eqnarray*}</div><p>for square matrices <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}.\)</span> The
standard eigenvalue problem is an example of the general eigenvalue
problem for <span class="math notranslate nohighlight">\(\mathbf{B}=\mathbf{I}.\)</span> When a generalized
eigenvalue problem can be solved, it provides a decomposition of
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span> as</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}=\mathbf{BV}\boldsymbol{\Lambda}\mathbf{V}^{-1},\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{V}\)</span> is the collection of eigenvectors into
columns and <span class="math notranslate nohighlight">\(\boldsymbol{\Lambda}\)</span> is a diagonal matrix of
eigenvalues.</p>
<p>By definition, eigenvectors are only defined up to a constant scale
factor. In SciPy, the scaling factor for the eigenvectors is chosen so
that <span class="math notranslate nohighlight">\(\left\Vert \mathbf{v}\right\Vert
^{2}=\sum_{i}v_{i}^{2}=1.\)</span></p>
<p>As an example, consider finding the eigenvalues and eigenvectors of
the matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{A}=\left[\begin{array}{ccc} 1 &amp; 5 &amp; 2\\ 2 &amp; 4 &amp; 1\\ 3 &amp; 6 &amp; 2\end{array}\right].\end{split}\]</div>
<p>The characteristic polynomial is</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \left|\mathbf{A}-\lambda\mathbf{I}\right| &amp; = &amp; \left(1-\lambda\right)\left[\left(4-\lambda\right)\left(2-\lambda\right)-6\right]-\\  &amp;  &amp; 5\left[2\left(2-\lambda\right)-3\right]+2\left[12-3\left(4-\lambda\right)\right]\\  &amp; = &amp; -\lambda^{3}+7\lambda^{2}+8\lambda-3.\end{eqnarray*}</div><p>The roots of this polynomial are the eigenvalues of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>:</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \lambda_{1} &amp; = &amp; 7.9579\\ \lambda_{2} &amp; = &amp; -1.2577\\ \lambda_{3} &amp; = &amp; 0.2997.\end{eqnarray*}</div><p>The eigenvectors corresponding to each eigenvalue can be found using
the original equation. The eigenvectors associated with these
eigenvalues can then be found.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">la</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">la</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>   <span class="c1"># eigenvalues</span>
<span class="go">(-0.3722813232690143+0j) (5.372281323269014+0j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>   <span class="c1"># first eigenvector</span>
<span class="go">[-0.82456484  0.56576746]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c1"># second eigenvector</span>
<span class="go">[-0.41597356 -0.90937671]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># eigenvectors are unitary</span>
<span class="go">[1. 1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">-</span> <span class="n">l1</span><span class="o">*</span><span class="n">v1</span><span class="p">))</span>  <span class="c1"># check the computation</span>
<span class="go">3.23682852457e-16</span>
</pre></div>
</div>
</section>
<section id="singular-value-decomposition">
<h3>Singular value decomposition<a class="headerlink" href="#singular-value-decomposition" title="Permalink to this headline">¶</a></h3>
<p>Singular value decomposition (SVD) can be thought of as an extension of
the eigenvalue problem to matrices that are not square. Let
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span> be an <span class="math notranslate nohighlight">\(M\times N\)</span> matrix with <span class="math notranslate nohighlight">\(M\)</span> and
<span class="math notranslate nohighlight">\(N\)</span> arbitrary. The matrices <span class="math notranslate nohighlight">\(\mathbf{A}^{H}\mathbf{A}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{A}^{H}\)</span> are square hermitian matrices <a class="footnote-reference brackets" href="#id3" id="id1">1</a> of
size <span class="math notranslate nohighlight">\(N\times N\)</span> and <span class="math notranslate nohighlight">\(M\times M\)</span>, respectively. It is known
that the eigenvalues of square hermitian matrices are real and
non-negative. In addition, there are at most
<span class="math notranslate nohighlight">\(\min\left(M,N\right)\)</span> identical non-zero eigenvalues of
<span class="math notranslate nohighlight">\(\mathbf{A}^{H}\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{A}^{H}.\)</span>
Define these positive eigenvalues as <span class="math notranslate nohighlight">\(\sigma_{i}^{2}.\)</span> The
square-root of these are called singular values of <span class="math notranslate nohighlight">\(\mathbf{A}.\)</span>
The eigenvectors of <span class="math notranslate nohighlight">\(\mathbf{A}^{H}\mathbf{A}\)</span> are collected by
columns into an <span class="math notranslate nohighlight">\(N\times N\)</span> unitary <a class="footnote-reference brackets" href="#id4" id="id2">2</a> matrix
<span class="math notranslate nohighlight">\(\mathbf{V}\)</span>, while the eigenvectors of
<span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{A}^{H}\)</span> are collected by columns in the
unitary matrix <span class="math notranslate nohighlight">\(\mathbf{U}\)</span>, the singular values are collected
in an <span class="math notranslate nohighlight">\(M\times N\)</span> zero matrix
<span class="math notranslate nohighlight">\(\mathbf{\boldsymbol{\Sigma}}\)</span> with main diagonal entries set to
the singular values. Then</p>
<div class="math notranslate nohighlight">
\[\mathbf{A=U}\boldsymbol{\Sigma}\mathbf{V}^{H}\]</div>
<p>is the singular value decomposition of <span class="math notranslate nohighlight">\(\mathbf{A}.\)</span> Every
matrix has a singular value decomposition. Sometimes, the singular
values are called the spectrum of <span class="math notranslate nohighlight">\(\mathbf{A}.\)</span> The command
<a class="reference internal" href="../reference/generated/scipy.linalg.svd.html#scipy.linalg.svd" title="scipy.linalg.svd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.svd</span></code></a> will return <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> ,
<span class="math notranslate nohighlight">\(\mathbf{V}^{H}\)</span>, and <span class="math notranslate nohighlight">\(\sigma_{i}\)</span> as an array of the
singular values. To obtain the matrix <span class="math notranslate nohighlight">\(\boldsymbol{\Sigma}\)</span>, use
<a class="reference internal" href="../reference/generated/scipy.linalg.diagsvd.html#scipy.linalg.diagsvd" title="scipy.linalg.diagsvd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.diagsvd</span></code></a>. The following example illustrates the use of
<a class="reference internal" href="../reference/generated/scipy.linalg.svd.html#scipy.linalg.svd" title="scipy.linalg.svd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.svd</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">      [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">Vh</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">diagsvd</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">U</span><span class="p">,</span> <span class="n">Vh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span>
<span class="go">array([[-0.3863177 , -0.92236578],</span>
<span class="go">      [-0.92236578,  0.3863177 ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span>
<span class="go">array([[ 9.508032  ,  0.        ,  0.        ],</span>
<span class="go">      [ 0.        ,  0.77286964,  0.        ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Vh</span>
<span class="go">array([[-0.42866713, -0.56630692, -0.7039467 ],</span>
<span class="go">      [ 0.80596391,  0.11238241, -0.58119908],</span>
<span class="go">      [ 0.40824829, -0.81649658,  0.40824829]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sig</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Vh</span><span class="p">))</span> <span class="c1">#check computation</span>
<span class="go">array([[ 1.,  2.,  3.],</span>
<span class="go">      [ 4.,  5.,  6.]])</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>A hermitian matrix <span class="math notranslate nohighlight">\(\mathbf{D}\)</span> satisfies <span class="math notranslate nohighlight">\(\mathbf{D}^{H}=\mathbf{D}.\)</span></p>
</dd>
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>A unitary matrix <span class="math notranslate nohighlight">\(\mathbf{D}\)</span> satisfies <span class="math notranslate nohighlight">\(\mathbf{D}^{H}\mathbf{D}=\mathbf{I}=\mathbf{D}\mathbf{D}^{H}\)</span> so that <span class="math notranslate nohighlight">\(\mathbf{D}^{-1}=\mathbf{D}^{H}.\)</span></p>
</dd>
</dl>
</section>
<section id="lu-decomposition">
<h3>LU decomposition<a class="headerlink" href="#lu-decomposition" title="Permalink to this headline">¶</a></h3>
<p>The LU decomposition finds a representation for the <span class="math notranslate nohighlight">\(M\times N\)</span>
matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> as</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}=\mathbf{P}\,\mathbf{L}\,\mathbf{U},\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> is an <span class="math notranslate nohighlight">\(M\times M\)</span> permutation matrix (a
permutation of the rows of the identity matrix), <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> is
in <span class="math notranslate nohighlight">\(M\times K\)</span> lower triangular or trapezoidal matrix (
<span class="math notranslate nohighlight">\(K=\min\left(M,N\right)\)</span>) with unit-diagonal, and
<span class="math notranslate nohighlight">\(\mathbf{U}\)</span> is an upper triangular or trapezoidal matrix. The
SciPy command for this decomposition is <a class="reference internal" href="../reference/generated/scipy.linalg.lu.html#scipy.linalg.lu" title="scipy.linalg.lu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.lu</span></code></a>.</p>
<p>Such a decomposition is often useful for solving many simultaneous
equations where the left-hand side does not change but the right-hand
side does. For example, suppose we are going to solve</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}\mathbf{x}_{i}=\mathbf{b}_{i}\]</div>
<p>for many different <span class="math notranslate nohighlight">\(\mathbf{b}_{i}\)</span>. The LU decomposition allows this to be written as</p>
<div class="math notranslate nohighlight">
\[\mathbf{PLUx}_{i}=\mathbf{b}_{i}.\]</div>
<p>Because <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> is lower-triangular, the equation can be
solved for <span class="math notranslate nohighlight">\(\mathbf{U}\mathbf{x}_{i}\)</span> and, finally,
<span class="math notranslate nohighlight">\(\mathbf{x}_{i}\)</span> very rapidly using forward- and
back-substitution. An initial time spent factoring <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>
allows for very rapid solution of similar systems of equations in the
future. If the intent for performing LU decomposition is for solving
linear systems, then the command <a class="reference internal" href="../reference/generated/scipy.linalg.lu_factor.html#scipy.linalg.lu_factor" title="scipy.linalg.lu_factor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.lu_factor</span></code></a> should be used
followed by repeated applications of the command
<a class="reference internal" href="../reference/generated/scipy.linalg.lu_solve.html#scipy.linalg.lu_solve" title="scipy.linalg.lu_solve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.lu_solve</span></code></a> to solve the system for each new
right-hand side.</p>
</section>
<section id="cholesky-decomposition">
<h3>Cholesky decomposition<a class="headerlink" href="#cholesky-decomposition" title="Permalink to this headline">¶</a></h3>
<p>Cholesky decomposition is a special case of LU decomposition
applicable to Hermitian positive definite matrices. When
<span class="math notranslate nohighlight">\(\mathbf{A}=\mathbf{A}^{H}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{x}^{H}\mathbf{Ax}\geq0\)</span> for all <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>,
then decompositions of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> can be found so that</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \mathbf{A} &amp; = &amp; \mathbf{U}^{H}\mathbf{U}\\ \mathbf{A} &amp; = &amp; \mathbf{L}\mathbf{L}^{H}\end{eqnarray*},</div><p>where <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> is lower triangular and <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> is
upper triangular. Notice that <span class="math notranslate nohighlight">\(\mathbf{L}=\mathbf{U}^{H}.\)</span> The
command <a class="reference internal" href="../reference/generated/scipy.linalg.cholesky.html#scipy.linalg.cholesky" title="scipy.linalg.cholesky"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.cholesky</span></code></a> computes the Cholesky
factorization. For using the Cholesky factorization to solve systems of
equations, there are also <a class="reference internal" href="../reference/generated/scipy.linalg.cho_factor.html#scipy.linalg.cho_factor" title="scipy.linalg.cho_factor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.cho_factor</span></code></a> and
<a class="reference internal" href="../reference/generated/scipy.linalg.cho_solve.html#scipy.linalg.cho_solve" title="scipy.linalg.cho_solve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.cho_solve</span></code></a> routines that work similarly to their LU
decomposition counterparts.</p>
</section>
<section id="qr-decomposition">
<h3>QR decomposition<a class="headerlink" href="#qr-decomposition" title="Permalink to this headline">¶</a></h3>
<p>The QR decomposition (sometimes called a polar decomposition) works
for any <span class="math notranslate nohighlight">\(M\times N\)</span> array and finds an <span class="math notranslate nohighlight">\(M\times M\)</span> unitary
matrix <span class="math notranslate nohighlight">\(\mathbf{Q}\)</span> and an <span class="math notranslate nohighlight">\(M\times N\)</span> upper-trapezoidal
matrix <span class="math notranslate nohighlight">\(\mathbf{R}\)</span>, such that</p>
<div class="math notranslate nohighlight">
\[\mathbf{A=QR}.\]</div>
<p>Notice that if the SVD of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is known, then the QR decomposition can be found.</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}=\mathbf{U}\boldsymbol{\Sigma}\mathbf{V}^{H}=\mathbf{QR}\]</div>
<p>implies that <span class="math notranslate nohighlight">\(\mathbf{Q}=\mathbf{U}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{R}=\boldsymbol{\Sigma}\mathbf{V}^{H}.\)</span> Note, however,
that in SciPy independent algorithms are used to find QR and SVD
decompositions. The command for QR decomposition is <a class="reference internal" href="../reference/generated/scipy.linalg.qr.html#scipy.linalg.qr" title="scipy.linalg.qr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.qr</span></code></a>.</p>
</section>
<section id="schur-decomposition">
<h3>Schur decomposition<a class="headerlink" href="#schur-decomposition" title="Permalink to this headline">¶</a></h3>
<p>For a square <span class="math notranslate nohighlight">\(N\times N\)</span> matrix, <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, the Schur
decomposition finds (not necessarily unique) matrices
<span class="math notranslate nohighlight">\(\mathbf{T}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span>, such that</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}=\mathbf{ZT}\mathbf{Z}^{H},\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> is a unitary matrix and <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> is
either upper triangular or quasi upper triangular, depending on whether
or not a real Schur form or complex Schur form is requested.  For a
real Schur form both <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> are
real-valued when <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is real-valued. When
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is a real-valued matrix, the real Schur form is only
quasi upper triangular because <span class="math notranslate nohighlight">\(2\times2\)</span> blocks extrude from
the main diagonal corresponding to any complex-valued
eigenvalues. The command <a class="reference internal" href="../reference/generated/scipy.linalg.schur.html#scipy.linalg.schur" title="scipy.linalg.schur"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.schur</span></code></a> finds the Schur
decomposition, while the command <a class="reference internal" href="../reference/generated/scipy.linalg.rsf2csf.html#scipy.linalg.rsf2csf" title="scipy.linalg.rsf2csf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.rsf2csf</span></code></a> converts
<span class="math notranslate nohighlight">\(\mathbf{T}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> from a real Schur form to a
complex Schur form. The Schur form is especially useful in calculating
functions of matrices.</p>
<p>The following example illustrates the Schur decomposition:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;[1 3 2; 1 4 5; 2 3 6]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T1</span><span class="p">,</span> <span class="n">Z1</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;complex&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T2</span><span class="p">,</span> <span class="n">Z2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">rsf2csf</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span>
<span class="go">array([[ 9.90012467,  1.78947961, -0.65498528],</span>
<span class="go">       [ 0.        ,  0.54993766, -1.57754789],</span>
<span class="go">       [ 0.        ,  0.51260928,  0.54993766]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T2</span>
<span class="go">array([[ 9.90012467+0.00000000e+00j, -0.32436598+1.55463542e+00j,</span>
<span class="go">        -0.88619748+5.69027615e-01j],</span>
<span class="go">       [ 0.        +0.00000000e+00j,  0.54993766+8.99258408e-01j,</span>
<span class="go">         1.06493862+3.05311332e-16j],</span>
<span class="go">       [ 0.        +0.00000000e+00j,  0.        +0.00000000e+00j,</span>
<span class="go">         0.54993766-8.99258408e-01j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">T1</span> <span class="o">-</span> <span class="n">T2</span><span class="p">)</span> <span class="c1"># different</span>
<span class="go">array([[  1.06604538e-14,   2.06969555e+00,   1.69375747e+00],  # may vary</span>
<span class="go">       [  0.00000000e+00,   1.33688556e-15,   4.74146496e-01],</span>
<span class="go">       [  0.00000000e+00,   0.00000000e+00,   1.13220977e-15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">Z1</span> <span class="o">-</span> <span class="n">Z2</span><span class="p">)</span> <span class="c1"># different</span>
<span class="go">array([[ 0.06833781,  0.88091091,  0.79568503],    # may vary</span>
<span class="go">       [ 0.11857169,  0.44491892,  0.99594171],</span>
<span class="go">       [ 0.12624999,  0.60264117,  0.77257633]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">Z1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">Z2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">,(</span><span class="n">T</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="n">Z1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">Z2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">Z</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">Z</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>  <span class="c1"># same</span>
<span class="go">matrix([[  5.55111512e-16,   1.77635684e-15,   2.22044605e-15],</span>
<span class="go">        [  0.00000000e+00,   3.99680289e-15,   8.88178420e-16],</span>
<span class="go">        [  1.11022302e-15,   4.44089210e-16,   3.55271368e-15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">Z1</span><span class="o">*</span><span class="n">T1</span><span class="o">*</span><span class="n">Z1</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>  <span class="c1"># same</span>
<span class="go">matrix([[  4.26993904e-15,   6.21793362e-15,   8.00007092e-15],</span>
<span class="go">        [  5.77945386e-15,   6.21798014e-15,   1.06653681e-14],</span>
<span class="go">        [  7.16681444e-15,   8.90271058e-15,   1.77635764e-14]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">Z2</span><span class="o">*</span><span class="n">T2</span><span class="o">*</span><span class="n">Z2</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>  <span class="c1"># same</span>
<span class="go">matrix([[  6.02594127e-16,   1.77648931e-15,   2.22506907e-15],</span>
<span class="go">        [  2.46275555e-16,   3.99684548e-15,   8.91642616e-16],</span>
<span class="go">        [  8.88225111e-16,   8.88312432e-16,   4.44104848e-15]])</span>
</pre></div>
</div>
</section>
<section id="interpolative-decomposition">
<h3>Interpolative decomposition<a class="headerlink" href="#interpolative-decomposition" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../reference/linalg.interpolative.html#module-scipy.linalg.interpolative" title="scipy.linalg.interpolative"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.linalg.interpolative</span></code></a> contains routines for computing the
interpolative decomposition (ID) of a matrix. For a matrix <span class="math notranslate nohighlight">\(A
\in \mathbb{C}^{m \times n}\)</span> of rank <span class="math notranslate nohighlight">\(k \leq \min \{ m, n \}\)</span>
this is a factorization</p>
<div class="math notranslate nohighlight">
\[A \Pi =
\begin{bmatrix}
 A \Pi_{1} &amp; A \Pi_{2}
\end{bmatrix} =
A \Pi_{1}
\begin{bmatrix}
 I &amp; T
\end{bmatrix},\]</div>
<p>where <span class="math notranslate nohighlight">\(\Pi = [\Pi_{1}, \Pi_{2}]\)</span> is a permutation matrix with
<span class="math notranslate nohighlight">\(\Pi_{1} \in \{ 0, 1 \}^{n \times k}\)</span>, i.e., <span class="math notranslate nohighlight">\(A \Pi_{2} =
A \Pi_{1} T\)</span>. This can equivalently be written as <span class="math notranslate nohighlight">\(A = BP\)</span>,
where <span class="math notranslate nohighlight">\(B = A \Pi_{1}\)</span> and <span class="math notranslate nohighlight">\(P = [I, T] \Pi^{\mathsf{T}}\)</span>
are the <em>skeleton</em> and <em>interpolation matrices</em>, respectively.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../reference/linalg.interpolative.html#module-scipy.linalg.interpolative" title="scipy.linalg.interpolative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.interpolative</span></code></a> — for more information.</p>
</div>
</section>
</section>
<section id="matrix-functions">
<h2>Matrix functions<a class="headerlink" href="#matrix-functions" title="Permalink to this headline">¶</a></h2>
<p>Consider the function <span class="math notranslate nohighlight">\(f\left(x\right)\)</span> with Taylor series expansion</p>
<div class="math notranslate nohighlight">
\[f\left(x\right)=\sum_{k=0}^{\infty}\frac{f^{\left(k\right)}\left(0\right)}{k!}x^{k}.\]</div>
<p>A matrix function can be defined using this Taylor series for the
square matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> as</p>
<div class="math notranslate nohighlight">
\[f\left(\mathbf{A}\right)=\sum_{k=0}^{\infty}\frac{f^{\left(k\right)}\left(0\right)}{k!}\mathbf{A}^{k}.\]</div>
<p>While this serves as a useful representation of a matrix function, it
is rarely the best way to calculate a matrix function.</p>
<section id="exponential-and-logarithm-functions">
<h3>Exponential and logarithm functions<a class="headerlink" href="#exponential-and-logarithm-functions" title="Permalink to this headline">¶</a></h3>
<p>The matrix exponential is one of the more common matrix functions.
The preferred method for implementing the matrix exponential is to use
scaling and a Padé approximation for <span class="math notranslate nohighlight">\(e^{x}\)</span>. This algorithm is
implemented as <a class="reference internal" href="../reference/generated/scipy.linalg.expm.html#scipy.linalg.expm" title="scipy.linalg.expm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.expm</span></code></a>.</p>
<p>The inverse of the matrix exponential is the matrix logarithm defined
as the inverse of the matrix exponential:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}\equiv\exp\left(\log\left(\mathbf{A}\right)\right).\]</div>
<p>The matrix logarithm can be obtained with <a class="reference internal" href="../reference/generated/scipy.linalg.logm.html#scipy.linalg.logm" title="scipy.linalg.logm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.logm</span></code></a>.</p>
</section>
<section id="trigonometric-functions">
<h3>Trigonometric functions<a class="headerlink" href="#trigonometric-functions" title="Permalink to this headline">¶</a></h3>
<p>The trigonometric functions, <span class="math notranslate nohighlight">\(\sin\)</span>, <span class="math notranslate nohighlight">\(\cos\)</span>, and
<span class="math notranslate nohighlight">\(\tan\)</span>, are implemented for matrices in <a class="reference internal" href="../reference/generated/scipy.linalg.sinm.html#scipy.linalg.sinm" title="scipy.linalg.sinm"><code class="xref py py-func docutils literal notranslate"><span class="pre">linalg.sinm</span></code></a>,
<a class="reference internal" href="../reference/generated/scipy.linalg.cosm.html#scipy.linalg.cosm" title="scipy.linalg.cosm"><code class="xref py py-func docutils literal notranslate"><span class="pre">linalg.cosm</span></code></a>, and <a class="reference internal" href="../reference/generated/scipy.linalg.tanm.html#scipy.linalg.tanm" title="scipy.linalg.tanm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.tanm</span></code></a>, respectively. The matrix
sine and cosine can be defined using Euler’s identity as</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \sin\left(\mathbf{A}\right) &amp; = &amp; \frac{e^{j\mathbf{A}}-e^{-j\mathbf{A}}}{2j}\\ \cos\left(\mathbf{A}\right) &amp; = &amp; \frac{e^{j\mathbf{A}}+e^{-j\mathbf{A}}}{2}.\end{eqnarray*}</div><p>The tangent is</p>
<div class="math notranslate nohighlight">
\[\tan\left(x\right)=\frac{\sin\left(x\right)}{\cos\left(x\right)}=\left[\cos\left(x\right)\right]^{-1}\sin\left(x\right)\]</div>
<p>and so the matrix tangent is defined as</p>
<div class="math notranslate nohighlight">
\[\left[\cos\left(\mathbf{A}\right)\right]^{-1}\sin\left(\mathbf{A}\right).\]</div>
</section>
<section id="hyperbolic-trigonometric-functions">
<h3>Hyperbolic trigonometric functions<a class="headerlink" href="#hyperbolic-trigonometric-functions" title="Permalink to this headline">¶</a></h3>
<p>The hyperbolic trigonometric functions, <span class="math notranslate nohighlight">\(\sinh\)</span>, <span class="math notranslate nohighlight">\(\cosh\)</span>,
and <span class="math notranslate nohighlight">\(\tanh\)</span>, can also be defined for matrices using the familiar
definitions:</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray*} \sinh\left(\mathbf{A}\right) &amp; = &amp; \frac{e^{\mathbf{A}}-e^{-\mathbf{A}}}{2}\\ \cosh\left(\mathbf{A}\right) &amp; = &amp; \frac{e^{\mathbf{A}}+e^{-\mathbf{A}}}{2}\\ \tanh\left(\mathbf{A}\right) &amp; = &amp; \left[\cosh\left(\mathbf{A}\right)\right]^{-1}\sinh\left(\mathbf{A}\right).\end{eqnarray*}</div><p>These matrix functions can be found using <a class="reference internal" href="../reference/generated/scipy.linalg.sinhm.html#scipy.linalg.sinhm" title="scipy.linalg.sinhm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.sinhm</span></code></a>,
<a class="reference internal" href="../reference/generated/scipy.linalg.coshm.html#scipy.linalg.coshm" title="scipy.linalg.coshm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.coshm</span></code></a>, and <a class="reference internal" href="../reference/generated/scipy.linalg.tanhm.html#scipy.linalg.tanhm" title="scipy.linalg.tanhm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.tanhm</span></code></a>.</p>
</section>
<section id="arbitrary-function">
<h3>Arbitrary function<a class="headerlink" href="#arbitrary-function" title="Permalink to this headline">¶</a></h3>
<p>Finally, any arbitrary function that takes one complex number and
returns a complex number can be called as a matrix function using the
command <a class="reference internal" href="../reference/generated/scipy.linalg.funm.html#scipy.linalg.funm" title="scipy.linalg.funm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.funm</span></code></a>. This command takes the matrix and an
arbitrary Python function. It then implements an algorithm from Golub
and Van Loan’s book “Matrix Computations” to compute the function applied
to the matrix using a Schur decomposition.  Note that <em>the function
needs to accept complex numbers</em> as input in order to work with this
algorithm. For example, the following code computes the zeroth-order
Bessel function applied to a matrix.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span><span class="p">,</span> <span class="n">linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">funm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">special</span><span class="o">.</span><span class="n">jv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[0.06369197, 0.90647174, 0.98024544],</span>
<span class="go">       [0.68752227, 0.5604377 , 0.49142032],</span>
<span class="go">       [0.86754578, 0.9746787 , 0.37932682]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span>
<span class="go">array([[ 0.6929219 , -0.29728805, -0.15930896],</span>
<span class="go">       [-0.16226043,  0.71967826, -0.22709386],</span>
<span class="go">       [-0.19945564, -0.33379957,  0.70259022]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([ 1.94835336+0.j, -0.72219681+0.j, -0.22270006+0.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">special</span><span class="o">.</span><span class="n">jv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">array([0.25375345+0.j, 0.87379738+0.j, 0.98763955+0.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">array([0.25375345+0.j, 0.87379738+0.j, 0.98763955+0.j])</span>
</pre></div>
</div>
<p>Note how, by virtue of how matrix analytic functions are defined,
the Bessel function has acted on the matrix eigenvalues.</p>
</section>
</section>
<section id="special-matrices">
<h2>Special matrices<a class="headerlink" href="#special-matrices" title="Permalink to this headline">¶</a></h2>
<p>SciPy and NumPy provide several functions for creating special matrices
that are frequently used in engineering and science.</p>
<table class="table">
<colgroup>
<col style="width: 18%" />
<col style="width: 30%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>block diagonal</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.block_diag.html#scipy.linalg.block_diag" title="scipy.linalg.block_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.block_diag</span></code></a></p></td>
<td><p>Create a block diagonal matrix from the provided arrays.</p></td>
</tr>
<tr class="row-odd"><td><p>circulant</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.circulant.html#scipy.linalg.circulant" title="scipy.linalg.circulant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.circulant</span></code></a></p></td>
<td><p>Create a circulant matrix.</p></td>
</tr>
<tr class="row-even"><td><p>companion</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.companion.html#scipy.linalg.companion" title="scipy.linalg.companion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.companion</span></code></a></p></td>
<td><p>Create a companion matrix.</p></td>
</tr>
<tr class="row-odd"><td><p>convolution</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.convolution_matrix.html#scipy.linalg.convolution_matrix" title="scipy.linalg.convolution_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.convolution_matrix</span></code></a></p></td>
<td><p>Create a convolution matrix.</p></td>
</tr>
<tr class="row-even"><td><p>Discrete Fourier</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.dft.html#scipy.linalg.dft" title="scipy.linalg.dft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.dft</span></code></a></p></td>
<td><p>Create a discrete Fourier transform matrix.</p></td>
</tr>
<tr class="row-odd"><td><p>Fiedler</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.fiedler.html#scipy.linalg.fiedler" title="scipy.linalg.fiedler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.fiedler</span></code></a></p></td>
<td><p>Create a symmetric Fiedler matrix.</p></td>
</tr>
<tr class="row-even"><td><p>Fiedler Companion</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.fiedler_companion.html#scipy.linalg.fiedler_companion" title="scipy.linalg.fiedler_companion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.fiedler_companion</span></code></a></p></td>
<td><p>Create a Fiedler companion matrix.</p></td>
</tr>
<tr class="row-odd"><td><p>Hadamard</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.hadamard.html#scipy.linalg.hadamard" title="scipy.linalg.hadamard"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.hadamard</span></code></a></p></td>
<td><p>Create an Hadamard matrix.</p></td>
</tr>
<tr class="row-even"><td><p>Hankel</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.hankel.html#scipy.linalg.hankel" title="scipy.linalg.hankel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.hankel</span></code></a></p></td>
<td><p>Create a Hankel matrix.</p></td>
</tr>
<tr class="row-odd"><td><p>Helmert</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.helmert.html#scipy.linalg.helmert" title="scipy.linalg.helmert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.helmert</span></code></a></p></td>
<td><p>Create a Helmert matrix.</p></td>
</tr>
<tr class="row-even"><td><p>Hilbert</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.hilbert.html#scipy.linalg.hilbert" title="scipy.linalg.hilbert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.hilbert</span></code></a></p></td>
<td><p>Create a Hilbert matrix.</p></td>
</tr>
<tr class="row-odd"><td><p>Inverse Hilbert</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.invhilbert.html#scipy.linalg.invhilbert" title="scipy.linalg.invhilbert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.invhilbert</span></code></a></p></td>
<td><p>Create the inverse of a Hilbert matrix.</p></td>
</tr>
<tr class="row-even"><td><p>Leslie</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.leslie.html#scipy.linalg.leslie" title="scipy.linalg.leslie"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.leslie</span></code></a></p></td>
<td><p>Create a Leslie matrix.</p></td>
</tr>
<tr class="row-odd"><td><p>Pascal</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.pascal.html#scipy.linalg.pascal" title="scipy.linalg.pascal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.pascal</span></code></a></p></td>
<td><p>Create a Pascal matrix.</p></td>
</tr>
<tr class="row-even"><td><p>Inverse Pascal</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.invpascal.html#scipy.linalg.invpascal" title="scipy.linalg.invpascal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.invpascal</span></code></a></p></td>
<td><p>Create the inverse of a Pascal matrix.</p></td>
</tr>
<tr class="row-odd"><td><p>Toeplitz</p></td>
<td><p><a class="reference internal" href="../reference/generated/scipy.linalg.toeplitz.html#scipy.linalg.toeplitz" title="scipy.linalg.toeplitz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.toeplitz</span></code></a></p></td>
<td><p>Create a Toeplitz matrix.</p></td>
</tr>
<tr class="row-even"><td><p>Van der Monde</p></td>
<td><p><a class="reference external" href="https://numpy.org/devdocs/reference/generated/numpy.vander.html#numpy.vander" title="(in NumPy v1.21.dev0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.vander</span></code></a></p></td>
<td><p>Create a Van der Monde matrix.</p></td>
</tr>
</tbody>
</table>
<p>For examples of the use of these functions, see their respective docstrings.</p>
</section>
</section>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="signal.html" title="previous page">Signal Processing (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal</span></code>)</a>
    <a class='right-next' id="next-link" href="arpack.html" title="next page">Sparse eigenvalue problems with ARPACK</a>

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2008-2021, The SciPy community.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.2.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>