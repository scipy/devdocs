
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Multidimensional image processing (scipy.ndimage) &#8212; SciPy v1.7.0.dev0+1036.4ec6f29 Manual</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../_static/scipy.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File IO (scipy.io)" href="io.html" />
    <link rel="prev" title="Wrapped Cauchy Distribution" href="stats/continuous_wrapcauchy.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../index.html">
  <img src="../_static/scipyshiny_small.png" class="logo" alt="logo">
</a>      


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../getting_started.html">
  Getting started
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../dev/index.html">
  Development
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../release.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/scipy/scipy" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="general.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="special.html">
   Special functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.special
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="integrate.html">
   Integration (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.integrate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optimize.html">
   Optimization (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.optimize
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="interpolate.html">
   Interpolation (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.interpolate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fft.html">
   Fourier Transforms (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.fft
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="signal.html">
   Signal Processing (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.signal
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linalg.html">
   Linear Algebra (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.linalg
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="arpack.html">
   Sparse eigenvalue problems with ARPACK
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="csgraph.html">
   Compressed Sparse Graph Routines (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.sparse.csgraph
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="spatial.html">
   Spatial data structures and algorithms (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.spatial
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stats.html">
   Statistics (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.stats
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Multidimensional image processing (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.ndimage
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="io.html">
   File IO (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.io
    </span>
   </code>
   )
  </a>
 </li>
</ul>

    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#properties-shared-by-all-functions">
   Properties shared by all functions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#filter-functions">
   Filter functions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#correlation-and-convolution">
     Correlation and convolution
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#smoothing-filters">
     Smoothing filters
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#filters-based-on-order-statistics">
     Filters based on order statistics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#derivatives">
     Derivatives
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#generic-filter-functions">
     Generic filter functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#fourier-domain-filters">
     Fourier domain filters
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interpolation-functions">
   Interpolation functions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spline-pre-filters">
     Spline pre-filters
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#interpolation-boundary-handling">
     Interpolation boundary handling
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     Interpolation functions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#morphology">
   Morphology
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#binary-morphology">
     Binary morphology
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#grey-scale-morphology">
     Grey-scale morphology
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#distance-transforms">
   Distance transforms
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#segmentation-and-labeling">
   Segmentation and labeling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#object-measurements">
   Object measurements
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#extending-scipy-ndimage-in-c">
   Extending
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.ndimage
    </span>
   </code>
   in C
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="multidimensional-image-processing-scipy-ndimage">
<h1>Multidimensional image processing (<a class="reference internal" href="../reference/ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage</span></code></a>)<a class="headerlink" href="#multidimensional-image-processing-scipy-ndimage" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<span id="ndimage-introduction"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Image processing and analysis are generally seen as operations on
2-D arrays of values. There are, however, a number of
fields where images of higher dimensionality must be analyzed. Good
examples of these are medical imaging and biological imaging.
<a class="reference external" href="https://numpy.org/devdocs/reference/index.html#module-numpy" title="(in NumPy v1.21.dev0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code></a> is suited very well for this type of applications due to
its inherent multidimensional nature. The <a class="reference internal" href="../reference/ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.ndimage</span></code></a>
packages provides a number of general image processing and analysis
functions that are designed to operate with arrays of arbitrary
dimensionality. The packages currently includes: functions for
linear and non-linear filtering, binary morphology, B-spline
interpolation, and object measurements.</p>
</section>
<section id="properties-shared-by-all-functions">
<span id="ndimage-properties-shared-by-all-functions"></span><h2>Properties shared by all functions<a class="headerlink" href="#properties-shared-by-all-functions" title="Permalink to this headline">¶</a></h2>
<p>All functions share some common properties. Notably, all functions
allow the specification of an output array with the <em>output</em>
argument. With this argument, you can specify an array that will be
changed in-place with the result with the operation. In this case,
the result is not returned. Usually, using the <em>output</em> argument is
more efficient, since an existing array is used to store the
result.</p>
<p>The type of arrays returned is dependent on the type of operation,
but it is, in most cases, equal to the type of the input. If,
however, the <em>output</em> argument is used, the type of the result is
equal to the type of the specified output argument. If no output
argument is given, it is still possible to specify what the result
of the output should be. This is done by simply assigning the
desired <a class="reference external" href="https://numpy.org/devdocs/reference/index.html#module-numpy" title="(in NumPy v1.21.dev0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a> type object to the output argument. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">correlate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="go">array([ 0,  2,  6,  9, 13, 16, 20, 23, 27, 30])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">],</span> <span class="n">output</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">array([  0. ,   2.5,   6. ,   9.5,  13. ,  16.5,  20. ,  23.5,  27. ,  30.5])</span>
</pre></div>
</div>
</section>
<section id="filter-functions">
<span id="ndimage-filter-functions"></span><h2>Filter functions<a class="headerlink" href="#filter-functions" title="Permalink to this headline">¶</a></h2>
<p>The functions described in this section all perform some type of spatial
filtering of the input array: the elements in the output are some function
of the values in the neighborhood of the corresponding input element. We refer
to this neighborhood of elements as the filter kernel, which is often
rectangular in shape but may also have an arbitrary footprint. Many
of the functions described below allow you to define the footprint
of the kernel by passing a mask through the <em>footprint</em> parameter.
For example, a cross-shaped kernel can be defined as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">footprint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">footprint</span>
<span class="go">array([[0, 1, 0],</span>
<span class="go">       [1, 1, 1],</span>
<span class="go">       [0, 1, 0]])</span>
</pre></div>
</div>
<p>Usually, the origin of the kernel is at the center calculated by
dividing the dimensions of the kernel shape by two. For instance,
the origin of a 1-D kernel of length three is at the
second element. Take, for example, the correlation of a
1-D array with a filter of length 3 consisting of
ones:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">correlate1d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([0, 0, 1, 1, 1, 0, 0])</span>
</pre></div>
</div>
<p>Sometimes, it is convenient to choose a different origin for the
kernel. For this reason, most functions support the <em>origin</em>
parameter, which gives the origin of the filter relative to its
center. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">origin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0, 1, 1, 1, 0, 0, 0])</span>
</pre></div>
</div>
<p>The effect is a shift of the result towards the left. This feature
will not be needed very often, but it may be useful, especially for
filters that have an even size. A good example is the calculation
of backward and forward differences:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>               <span class="c1"># backward difference</span>
<span class="go">array([ 0,  0,  1,  0,  0, -1,  0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">origin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># forward difference</span>
<span class="go">array([ 0,  1,  0,  0, -1,  0,  0])</span>
</pre></div>
</div>
<p>We could also have calculated the forward difference as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([ 0,  1,  0,  0, -1,  0,  0])</span>
</pre></div>
</div>
<p>However, using the origin parameter instead of a larger kernel is
more efficient. For multidimensional kernels, <em>origin</em> can be a
number, in which case the origin is assumed to be equal along all
axes, or a sequence giving the origin along each axis.</p>
<p>Since the output elements are a function of elements in the
neighborhood of the input elements, the borders of the array need to
be dealt with appropriately by providing the values outside the
borders. This is done by assuming that the arrays are extended beyond
their boundaries according to certain boundary conditions. In the
functions described below, the boundary conditions can be selected
using the <em>mode</em> parameter, which must be a string with the name of the
boundary condition. The following boundary conditions are currently
supported:</p>
<blockquote>
<div><table class="table">
<colgroup>
<col style="width: 15%" />
<col style="width: 55%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>mode</strong></p></th>
<th class="head"><p><strong>description</strong></p></th>
<th class="head"><p><strong>example</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“nearest”</p></td>
<td><p>use the value at the boundary</p></td>
<td><p>[1 2 3]-&gt;[1 1 2 3 3]</p></td>
</tr>
<tr class="row-odd"><td><p>“wrap”</p></td>
<td><p>periodically replicate the array</p></td>
<td><p>[1 2 3]-&gt;[3 1 2 3 1]</p></td>
</tr>
<tr class="row-even"><td><p>“reflect”</p></td>
<td><p>reflect the array at the boundary</p></td>
<td><p>[1 2 3]-&gt;[1 1 2 3 3]</p></td>
</tr>
<tr class="row-odd"><td><p>“mirror”</p></td>
<td><p>mirror the array at the boundary</p></td>
<td><p>[1 2 3]-&gt;[2 1 2 3 2]</p></td>
</tr>
<tr class="row-even"><td><p>“constant”</p></td>
<td><p>use a constant value, default is 0.0</p></td>
<td><p>[1 2 3]-&gt;[0 1 2 3 0]</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The following synonyms are also supported for consistency with the
interpolation routines:</p>
<blockquote>
<div><table class="table">
<colgroup>
<col style="width: 38%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>mode</strong></p></th>
<th class="head"><p><strong>description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“grid-constant”</p></td>
<td><p>equivalent to “constant”*</p></td>
</tr>
<tr class="row-odd"><td><p>“grid-mirror”</p></td>
<td><p>equivalent to “reflect”</p></td>
</tr>
<tr class="row-even"><td><p>“grid-wrap”</p></td>
<td><p>equivalent to “wrap”</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>* “grid-constant” and “constant” are equivalent for filtering operations, but
have different behavior in interpolation functions. For API consistency, the
filtering functions accept either name.</p>
<p>The “constant” mode is special since it needs an additional parameter to
specify the constant value that should be used.</p>
<p>Note that modes mirror and reflect differ only in whether the sample at the
boundary is repeated upon reflection. For mode mirror, the point of symmetry is
exactly at the final sample, so that value is not repeated. This mode is also
known as whole-sample symmetric since the point of symmetry falls on the final
sample. Similarly, reflect is often refered to as half-sample symmetric as the
point of symmetry is half a sample beyond the array boundary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The easiest way to implement such boundary conditions would be to
copy the data to a larger array and extend the data at the borders
according to the boundary conditions. For large arrays and large
filter kernels, this would be very memory consuming, and the
functions described below, therefore, use a different approach that
does not require allocating large temporary buffers.</p>
</div>
<section id="correlation-and-convolution">
<h3>Correlation and convolution<a class="headerlink" href="#correlation-and-convolution" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.correlate1d.html#scipy.ndimage.correlate1d" title="scipy.ndimage.correlate1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">correlate1d</span></code></a> function calculates a 1-D
correlation along the given axis. The lines of the array along the
given axis are correlated with the given <em>weights</em>. The <em>weights</em>
parameter must be a 1-D sequence of numbers.</p></li>
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.correlate.html#scipy.ndimage.correlate" title="scipy.ndimage.correlate"><code class="xref py py-func docutils literal notranslate"><span class="pre">correlate</span></code></a> implements multidimensional
correlation of the input array with a given kernel.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.convolve1d.html#scipy.ndimage.convolve1d" title="scipy.ndimage.convolve1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">convolve1d</span></code></a> function calculates a 1-D
convolution along the given axis. The lines of the array along the
given axis are convoluted with the given <em>weights</em>. The <em>weights</em>
parameter must be a 1-D sequence of numbers.</p></li>
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve" title="scipy.ndimage.convolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">convolve</span></code></a> implements multidimensional
convolution of the input array with a given kernel.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A convolution is essentially a correlation after mirroring the
kernel. As a result, the <em>origin</em> parameter behaves differently
than in the case of a correlation: the results is shifted in the
opposite direction.</p>
</div>
</li>
</ul>
</section>
<section id="smoothing-filters">
<span id="ndimage-filter-functions-smoothing"></span><h3>Smoothing filters<a class="headerlink" href="#smoothing-filters" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.gaussian_filter1d.html#scipy.ndimage.gaussian_filter1d" title="scipy.ndimage.gaussian_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">gaussian_filter1d</span></code></a> function implements a 1-D
Gaussian filter. The standard deviation of the Gaussian filter is
passed through the parameter <em>sigma</em>. Setting <em>order</em> = 0
corresponds to convolution with a Gaussian kernel. An order of 1, 2,
or 3 corresponds to convolution with the first, second, or third
derivatives of a Gaussian. Higher-order derivatives are not
implemented.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter" title="scipy.ndimage.gaussian_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">gaussian_filter</span></code></a> function implements a multidimensional
Gaussian filter. The standard deviations of the Gaussian filter
along each axis are passed through the parameter <em>sigma</em> as a
sequence or numbers. If <em>sigma</em> is not a sequence but a single
number, the standard deviation of the filter is equal along all
directions. The order of the filter can be specified separately for
each axis. An order of 0 corresponds to convolution with a Gaussian
kernel. An order of 1, 2, or 3 corresponds to convolution with the
first, second, or third derivatives of a Gaussian. Higher-order
derivatives are not implemented. The <em>order</em> parameter must be a
number, to specify the same order for all axes, or a sequence of
numbers to specify a different order for each axis.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The multidimensional filter is implemented as a sequence of
1-D Gaussian filters. The intermediate arrays are
stored in the same data type as the output. Therefore, for
output types with a lower precision, the results may be imprecise
because intermediate results may be stored with insufficient
precision. This can be prevented by specifying a more precise
output type.</p>
</div>
</li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.uniform_filter1d.html#scipy.ndimage.uniform_filter1d" title="scipy.ndimage.uniform_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">uniform_filter1d</span></code></a> function calculates a 1-D
uniform filter of the given <em>size</em> along the given axis.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.uniform_filter.html#scipy.ndimage.uniform_filter" title="scipy.ndimage.uniform_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">uniform_filter</span></code></a> implements a multidimensional uniform
filter. The sizes of the uniform filter are given for each axis as a
sequence of integers by the <em>size</em> parameter. If <em>size</em> is not a
sequence, but a single number, the sizes along all axes are assumed
to be equal.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The multidimensional filter is implemented as a sequence of
1-D uniform filters. The intermediate arrays are
stored in the same data type as the output. Therefore, for output
types with a lower precision, the results may be imprecise
because intermediate results may be stored with insufficient
precision. This can be prevented by specifying a more precise
output type.</p>
</div>
</li>
</ul>
</section>
<section id="filters-based-on-order-statistics">
<h3>Filters based on order statistics<a class="headerlink" href="#filters-based-on-order-statistics" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.minimum_filter1d.html#scipy.ndimage.minimum_filter1d" title="scipy.ndimage.minimum_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum_filter1d</span></code></a> function calculates a 1-D
minimum filter of the given <em>size</em> along the given axis.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.maximum_filter1d.html#scipy.ndimage.maximum_filter1d" title="scipy.ndimage.maximum_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum_filter1d</span></code></a> function calculates a 1-D
maximum filter of the given <em>size</em> along the given axis.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.minimum_filter.html#scipy.ndimage.minimum_filter" title="scipy.ndimage.minimum_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum_filter</span></code></a> function calculates a multidimensional
minimum filter. Either the sizes of a rectangular kernel or the
footprint of the kernel must be provided. The <em>size</em> parameter, if
provided, must be a sequence of sizes or a single number, in which
case the size of the filter is assumed to be equal along each axis.
The <em>footprint</em>, if provided, must be an array that defines the
shape of the kernel by its non-zero elements.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.maximum_filter.html#scipy.ndimage.maximum_filter" title="scipy.ndimage.maximum_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum_filter</span></code></a> function calculates a multidimensional
maximum filter. Either the sizes of a rectangular kernel or the
footprint of the kernel must be provided. The <em>size</em> parameter, if
provided, must be a sequence of sizes or a single number, in which
case the size of the filter is assumed to be equal along each axis.
The <em>footprint</em>, if provided, must be an array that defines the
shape of the kernel by its non-zero elements.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.rank_filter.html#scipy.ndimage.rank_filter" title="scipy.ndimage.rank_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">rank_filter</span></code></a> function calculates a multidimensional rank
filter. The <em>rank</em> may be less then zero, i.e., <em>rank</em> = -1
indicates the largest element. Either the sizes of a rectangular
kernel or the footprint of the kernel must be provided. The <em>size</em>
parameter, if provided, must be a sequence of sizes or a single
number, in which case the size of the filter is assumed to be equal
along each axis. The <em>footprint</em>, if provided, must be an array that
defines the shape of the kernel by its non-zero elements.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.percentile_filter.html#scipy.ndimage.percentile_filter" title="scipy.ndimage.percentile_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">percentile_filter</span></code></a> function calculates a multidimensional
percentile filter. The <em>percentile</em> may be less then zero, i.e.,
<em>percentile</em> = -20 equals <em>percentile</em> = 80. Either the sizes of a
rectangular kernel or the footprint of the kernel must be provided.
The <em>size</em> parameter, if provided, must be a sequence of sizes or a
single number, in which case the size of the filter is assumed to be
equal along each axis. The <em>footprint</em>, if provided, must be an
array that defines the shape of the kernel by its non-zero elements.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.median_filter.html#scipy.ndimage.median_filter" title="scipy.ndimage.median_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">median_filter</span></code></a> function calculates a multidimensional
median filter. Either the sizes of a rectangular kernel or the
footprint of the kernel must be provided. The <em>size</em> parameter, if
provided, must be a sequence of sizes or a single number, in which
case the size of the filter is assumed to be equal along each
axis. The <em>footprint</em> if provided, must be an array that defines the
shape of the kernel by its non-zero elements.</p></li>
</ul>
</section>
<section id="derivatives">
<h3>Derivatives<a class="headerlink" href="#derivatives" title="Permalink to this headline">¶</a></h3>
<p>Derivative filters can be constructed in several ways. The function
<a class="reference internal" href="../reference/generated/scipy.ndimage.gaussian_filter1d.html#scipy.ndimage.gaussian_filter1d" title="scipy.ndimage.gaussian_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">gaussian_filter1d</span></code></a>, described in
<a class="reference internal" href="#ndimage-filter-functions-smoothing"><span class="std std-ref">Smoothing filters</span></a>, can be used to calculate
derivatives along a given axis using the <em>order</em> parameter. Other
derivative filters are the Prewitt and Sobel filters:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.prewitt.html#scipy.ndimage.prewitt" title="scipy.ndimage.prewitt"><code class="xref py py-func docutils literal notranslate"><span class="pre">prewitt</span></code></a> function calculates a derivative along the given
axis.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel" title="scipy.ndimage.sobel"><code class="xref py py-func docutils literal notranslate"><span class="pre">sobel</span></code></a> function calculates a derivative along the given
axis.</p></li>
</ul>
<p>The Laplace filter is calculated by the sum of the second derivatives
along all axes. Thus, different Laplace filters can be constructed
using different second-derivative functions. Therefore, we provide a
general function that takes a function argument to calculate the
second derivative along a given direction.</p>
<ul>
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace" title="scipy.ndimage.generic_laplace"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_laplace</span></code></a> calculates a Laplace filter
using the function passed through <code class="docutils literal notranslate"><span class="pre">derivative2</span></code> to calculate
second derivatives. The function <code class="docutils literal notranslate"><span class="pre">derivative2</span></code> should have the
following signature</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">derivative2</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="o">*</span><span class="n">extra_arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_keywords</span><span class="p">)</span>
</pre></div>
</div>
<p>It should calculate the second derivative along the dimension
<em>axis</em>. If <em>output</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, it should use that for the
output and return <code class="docutils literal notranslate"><span class="pre">None</span></code>, otherwise it should return the
result. <em>mode</em>, <em>cval</em> have the usual meaning.</p>
<p>The <em>extra_arguments</em> and <em>extra_keywords</em> arguments can be used
to pass a tuple of extra arguments and a dictionary of named
arguments that are passed to <code class="docutils literal notranslate"><span class="pre">derivative2</span></code> at each call.</p>
<p>For example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">d2</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">correlate1d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">generic_laplace</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_laplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -4.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
<p>To demonstrate the use of the <em>extra_arguments</em> argument, we could do</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">d2</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">correlate1d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="mi">0</span><span class="p">,)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_laplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">extra_arguments</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],))</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -4.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">generic_laplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">extra_keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1., -4.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</li>
</ul>
<p>The following two functions are implemented using
<a class="reference internal" href="../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace" title="scipy.ndimage.generic_laplace"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_laplace</span></code></a> by providing appropriate functions for the
second-derivative function:</p>
<ul class="simple">
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.laplace.html#scipy.ndimage.laplace" title="scipy.ndimage.laplace"><code class="xref py py-func docutils literal notranslate"><span class="pre">laplace</span></code></a> calculates the Laplace using discrete
differentiation for the second derivative (i.e., convolution with
<code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">-2,</span> <span class="pre">1]</span></code>).</p></li>
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.gaussian_laplace.html#scipy.ndimage.gaussian_laplace" title="scipy.ndimage.gaussian_laplace"><code class="xref py py-func docutils literal notranslate"><span class="pre">gaussian_laplace</span></code></a> calculates the Laplace filter
using <a class="reference internal" href="../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter" title="scipy.ndimage.gaussian_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">gaussian_filter</span></code></a> to calculate the second
derivatives. The standard deviations of the Gaussian filter along
each axis are passed through the parameter <em>sigma</em> as a sequence or
numbers. If <em>sigma</em> is not a sequence but a single number, the
standard deviation of the filter is equal along all directions.</p></li>
</ul>
<p>The gradient magnitude is defined as the square root of the sum of the
squares of the gradients in all directions. Similar to the generic
Laplace function, there is a <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude" title="scipy.ndimage.generic_gradient_magnitude"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_gradient_magnitude</span></code></a>
function that calculates the gradient magnitude of an array.</p>
<ul>
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude" title="scipy.ndimage.generic_gradient_magnitude"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_gradient_magnitude</span></code></a> calculates a
gradient magnitude using the function passed through
<code class="docutils literal notranslate"><span class="pre">derivative</span></code> to calculate first derivatives. The function
<code class="docutils literal notranslate"><span class="pre">derivative</span></code> should have the following signature</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="o">*</span><span class="n">extra_arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_keywords</span><span class="p">)</span>
</pre></div>
</div>
<p>It should calculate the derivative along the dimension <em>axis</em>. If
<em>output</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, it should use that for the output and return
<code class="docutils literal notranslate"><span class="pre">None</span></code>, otherwise it should return the result. <em>mode</em>, <em>cval</em> have the
usual meaning.</p>
<p>The <em>extra_arguments</em> and <em>extra_keywords</em> arguments can be used to
pass a tuple of extra arguments and a dictionary of named arguments
that are passed to <em>derivative</em> at each call.</p>
<p>For example, the <a class="reference internal" href="../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel" title="scipy.ndimage.sobel"><code class="xref py py-func docutils literal notranslate"><span class="pre">sobel</span></code></a> function fits the required signature</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">sobel</span><span class="p">,</span> <span class="n">generic_gradient_magnitude</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_gradient_magnitude</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sobel</span><span class="p">)</span>
<span class="go">array([[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  1.41421356,  2.        ,  1.41421356,  0.        ],</span>
<span class="go">       [ 0.        ,  2.        ,  0.        ,  2.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  1.41421356,  2.        ,  1.41421356,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])</span>
</pre></div>
</div>
<p>See the documentation of <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace" title="scipy.ndimage.generic_laplace"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_laplace</span></code></a> for examples of
using the <em>extra_arguments</em> and <em>extra_keywords</em> arguments.</p>
</li>
</ul>
<p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel" title="scipy.ndimage.sobel"><code class="xref py py-func docutils literal notranslate"><span class="pre">sobel</span></code></a> and <a class="reference internal" href="../reference/generated/scipy.ndimage.prewitt.html#scipy.ndimage.prewitt" title="scipy.ndimage.prewitt"><code class="xref py py-func docutils literal notranslate"><span class="pre">prewitt</span></code></a> functions fit the required
signature and can, therefore, be used directly with
<a class="reference internal" href="../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude" title="scipy.ndimage.generic_gradient_magnitude"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_gradient_magnitude</span></code></a>.</p>
<ul class="simple">
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.gaussian_gradient_magnitude.html#scipy.ndimage.gaussian_gradient_magnitude" title="scipy.ndimage.gaussian_gradient_magnitude"><code class="xref py py-func docutils literal notranslate"><span class="pre">gaussian_gradient_magnitude</span></code></a> calculates the
gradient magnitude using <a class="reference internal" href="../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter" title="scipy.ndimage.gaussian_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">gaussian_filter</span></code></a> to calculate the
first derivatives. The standard deviations of the Gaussian filter
along each axis are passed through the parameter <em>sigma</em> as a
sequence or numbers. If <em>sigma</em> is not a sequence but a single
number, the standard deviation of the filter is equal along all
directions.</p></li>
</ul>
</section>
<section id="generic-filter-functions">
<span id="ndimage-genericfilters"></span><h3>Generic filter functions<a class="headerlink" href="#generic-filter-functions" title="Permalink to this headline">¶</a></h3>
<p>To implement filter functions, generic functions can be used that
accept a callable object that implements the filtering operation. The
iteration over the input and output arrays is handled by these generic
functions, along with such details as the implementation of the
boundary conditions. Only a callable object implementing a callback
function that does the actual filtering work must be provided. The
callback function can also be written in C and passed using a
<a class="reference external" href="https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule" title="(in Python v3.11)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCapsule</span></code></a> (see <a class="reference internal" href="#ndimage-ccallbacks"><span class="std std-ref">Extending scipy.ndimage in C</span></a> for more
information).</p>
<ul>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_filter1d</span></code></a> function implements a generic
1-D filter function, where the actual filtering
operation must be supplied as a python function (or other callable
object). The <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_filter1d</span></code></a> function iterates over the
lines of an array and calls <code class="docutils literal notranslate"><span class="pre">function</span></code> at each line. The
arguments that are passed to <code class="docutils literal notranslate"><span class="pre">function</span></code> are 1-D
arrays of the <code class="docutils literal notranslate"><span class="pre">numpy.float64</span></code> type. The first contains the values
of the current line. It is extended at the beginning and the end,
according to the <em>filter_size</em> and <em>origin</em> arguments. The second
array should be modified in-place to provide the output values of
the line. For example, consider a correlation along one dimension:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([[ 3,  8, 14, 17],</span>
<span class="go">       [27, 32, 38, 41],</span>
<span class="go">       [51, 56, 62, 65]])</span>
</pre></div>
</div>
<p>The same operation can be implemented using <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_filter1d</span></code></a>,
as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fnc</span><span class="p">(</span><span class="n">iline</span><span class="p">,</span> <span class="n">oline</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">oline</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">iline</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">generic_filter1d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([[ 3,  8, 14, 17],</span>
<span class="go">       [27, 32, 38, 41],</span>
<span class="go">       [51, 56, 62, 65]])</span>
</pre></div>
</div>
<p>Here, the origin of the kernel was (by default) assumed to be in the
middle of the filter of length 3. Therefore, each input line had been
extended by one value at the beginning and at the end, before the
function was called.</p>
<p>Optionally, extra arguments can be defined and passed to the filter
function. The <em>extra_arguments</em> and <em>extra_keywords</em> arguments can
be used to pass a tuple of extra arguments and/or a dictionary of
named arguments that are passed to derivative at each call. For
example, we can pass the parameters of our filter as an argument</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fnc</span><span class="p">(</span><span class="n">iline</span><span class="p">,</span> <span class="n">oline</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">oline</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">iline</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">extra_arguments</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[ 3,  8, 14, 17],</span>
<span class="go">       [27, 32, 38, 41],</span>
<span class="go">       [51, 56, 62, 65]])</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">extra_keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">})</span>
<span class="go">array([[ 3,  8, 14, 17],</span>
<span class="go">       [27, 32, 38, 41],</span>
<span class="go">       [51, 56, 62, 65]])</span>
</pre></div>
</div>
</li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter" title="scipy.ndimage.generic_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_filter</span></code></a> function implements a generic filter
function, where the actual filtering operation must be supplied as a
python function (or other callable object). The
<a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter" title="scipy.ndimage.generic_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_filter</span></code></a> function iterates over the array and calls
<code class="docutils literal notranslate"><span class="pre">function</span></code> at each element. The argument of <code class="docutils literal notranslate"><span class="pre">function</span></code>
is a 1-D array of the <code class="docutils literal notranslate"><span class="pre">numpy.float64</span></code> type that
contains the values around the current element that are within the
footprint of the filter. The function should return a single value
that can be converted to a double precision number. For example,
consider a correlation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="go">array([[ 0,  3,  7, 11],</span>
<span class="go">       [12, 15, 19, 23],</span>
<span class="go">       [28, 31, 35, 39]])</span>
</pre></div>
</div>
<p>The same operation can be implemented using <em>generic_filter</em>, as
follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fnc</span><span class="p">(</span><span class="n">buffer</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">generic_filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="n">footprint</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">array([[ 0,  3,  7, 11],</span>
<span class="go">       [12, 15, 19, 23],</span>
<span class="go">       [28, 31, 35, 39]])</span>
</pre></div>
</div>
<p>Here, a kernel footprint was specified that contains only two
elements. Therefore, the filter function receives a buffer of length
equal to two, which was multiplied with the proper weights and the
result summed.</p>
<p>When calling <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter" title="scipy.ndimage.generic_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_filter</span></code></a>, either the sizes of a
rectangular kernel or the footprint of the kernel must be
provided. The <em>size</em> parameter, if provided, must be a sequence of
sizes or a single number, in which case the size of the filter is
assumed to be equal along each axis. The <em>footprint</em>, if provided,
must be an array that defines the shape of the kernel by its
non-zero elements.</p>
<p>Optionally, extra arguments can be defined and passed to the filter
function. The <em>extra_arguments</em> and <em>extra_keywords</em> arguments can
be used to pass a tuple of extra arguments and/or a dictionary of
named arguments that are passed to derivative at each call. For
example, we can pass the parameters of our filter as an argument</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fnc</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="n">footprint</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">extra_arguments</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],))</span>
<span class="go">array([[ 0,  3,  7, 11],</span>
<span class="go">       [12, 15, 19, 23],</span>
<span class="go">       [28, 31, 35, 39]])</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="p">,</span> <span class="n">footprint</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">extra_keywords</span><span class="o">=</span> <span class="p">{</span><span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="go">array([[ 0,  3,  7, 11],</span>
<span class="go">       [12, 15, 19, 23],</span>
<span class="go">       [28, 31, 35, 39]])</span>
</pre></div>
</div>
</li>
</ul>
<p>These functions iterate over the lines or elements starting at the
last axis, i.e., the last index changes the fastest. This order of
iteration is guaranteed for the case that it is important to adapt the
filter depending on spatial location. Here is an example of using a
class that implements the filter and keeps track of the current
coordinates while iterating. It performs the same filter operation as
described above for <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter" title="scipy.ndimage.generic_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_filter</span></code></a>, but additionally prints
the current coordinates:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">fnc_class</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># store the shape:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
<span class="gp">... </span>        <span class="c1"># initialize the coordinates:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
<span class="gp">... </span>        <span class="c1"># calculate the next coordinates:</span>
<span class="gp">... </span>        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
<span class="gp">... </span>        <span class="n">axes</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>                <span class="k">break</span>
<span class="gp">... </span>            <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">result</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fnc</span> <span class="o">=</span> <span class="n">fnc_class</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="o">.</span><span class="n">filter</span><span class="p">,</span> <span class="n">footprint</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">[0, 0]</span>
<span class="go">[0, 1]</span>
<span class="go">[0, 2]</span>
<span class="go">[0, 3]</span>
<span class="go">[1, 0]</span>
<span class="go">[1, 1]</span>
<span class="go">[1, 2]</span>
<span class="go">[1, 3]</span>
<span class="go">[2, 0]</span>
<span class="go">[2, 1]</span>
<span class="go">[2, 2]</span>
<span class="go">[2, 3]</span>
<span class="go">array([[ 0,  3,  7, 11],</span>
<span class="go">       [12, 15, 19, 23],</span>
<span class="go">       [28, 31, 35, 39]])</span>
</pre></div>
</div>
<p>For the <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_filter1d</span></code></a> function, the same approach works,
except that this function does not iterate over the axis that is being
filtered. The example for <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_filter1d</span></code></a> then becomes this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">fnc1d_class</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># store the filter axis:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
<span class="gp">... </span>        <span class="c1"># store the shape:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
<span class="gp">... </span>        <span class="c1"># initialize the coordinates:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iline</span><span class="p">,</span> <span class="n">oline</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">oline</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">iline</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">iline</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
<span class="gp">... </span>        <span class="c1"># calculate the next coordinates:</span>
<span class="gp">... </span>        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
<span class="gp">... </span>        <span class="c1"># skip the filter axis:</span>
<span class="gp">... </span>        <span class="k">del</span> <span class="n">axes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span>
<span class="gp">... </span>        <span class="n">axes</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>                <span class="k">break</span>
<span class="gp">... </span>            <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fnc</span> <span class="o">=</span> <span class="n">fnc1d_class</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generic_filter1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fnc</span><span class="o">.</span><span class="n">filter</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 0]</span>
<span class="go">[1, 0]</span>
<span class="go">[2, 0]</span>
<span class="go">array([[ 3,  8, 14, 17],</span>
<span class="go">       [27, 32, 38, 41],</span>
<span class="go">       [51, 56, 62, 65]])</span>
</pre></div>
</div>
</section>
<section id="fourier-domain-filters">
<h3>Fourier domain filters<a class="headerlink" href="#fourier-domain-filters" title="Permalink to this headline">¶</a></h3>
<p>The functions described in this section perform filtering
operations in the Fourier domain. Thus, the input array of such a
function should be compatible with an inverse Fourier transform
function, such as the functions from the <a class="reference external" href="https://numpy.org/devdocs/reference/routines.fft.html#module-numpy.fft" title="(in NumPy v1.21.dev0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy.fft</span></code></a> module. We,
therefore, have to deal with arrays that may be the result of a real
or a complex Fourier transform. In the case of a real Fourier
transform, only half of the of the symmetric complex transform is
stored. Additionally, it needs to be known what the length of the
axis was that was transformed by the real fft. The functions
described here provide a parameter <em>n</em> that, in the case of a real
transform, must be equal to the length of the real transform axis
before transformation. If this parameter is less than zero, it is
assumed that the input array was the result of a complex Fourier
transform. The parameter <em>axis</em> can be used to indicate along which
axis the real transform was executed.</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.fourier_shift.html#scipy.ndimage.fourier_shift" title="scipy.ndimage.fourier_shift"><code class="xref py py-func docutils literal notranslate"><span class="pre">fourier_shift</span></code></a> function multiplies the input array with
the multidimensional Fourier transform of a shift operation for the
given shift. The <em>shift</em> parameter is a sequence of shifts for each
dimension or a single value for all dimensions.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.fourier_gaussian.html#scipy.ndimage.fourier_gaussian" title="scipy.ndimage.fourier_gaussian"><code class="xref py py-func docutils literal notranslate"><span class="pre">fourier_gaussian</span></code></a> function multiplies the input array
with the multidimensional Fourier transform of a Gaussian filter
with given standard deviations <em>sigma</em>. The <em>sigma</em> parameter is a
sequence of values for each dimension or a single value for all
dimensions.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.fourier_uniform.html#scipy.ndimage.fourier_uniform" title="scipy.ndimage.fourier_uniform"><code class="xref py py-func docutils literal notranslate"><span class="pre">fourier_uniform</span></code></a> function multiplies the input array with
the multidimensional Fourier transform of a uniform filter with
given sizes <em>size</em>. The <em>size</em> parameter is a sequence of values
for each dimension or a single value for all dimensions.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.fourier_ellipsoid.html#scipy.ndimage.fourier_ellipsoid" title="scipy.ndimage.fourier_ellipsoid"><code class="xref py py-func docutils literal notranslate"><span class="pre">fourier_ellipsoid</span></code></a> function multiplies the input array
with the multidimensional Fourier transform of an elliptically-shaped
filter with given sizes <em>size</em>. The <em>size</em> parameter is a sequence
of values for each dimension or a single value for all dimensions.
This function is only implemented for dimensions 1, 2, and 3.</p></li>
</ul>
</section>
</section>
<section id="interpolation-functions">
<span id="ndimage-interpolation"></span><h2>Interpolation functions<a class="headerlink" href="#interpolation-functions" title="Permalink to this headline">¶</a></h2>
<p>This section describes various interpolation functions that are based
on B-spline theory. A good introduction to B-splines can be found
in <a class="footnote-reference brackets" href="#id8" id="id1">1</a> with detailed algorithms for image interpolation given in <a class="footnote-reference brackets" href="#id12" id="id2">5</a>.</p>
<section id="spline-pre-filters">
<h3>Spline pre-filters<a class="headerlink" href="#spline-pre-filters" title="Permalink to this headline">¶</a></h3>
<p>Interpolation using splines of an order larger than 1 requires a
pre-filtering step. The interpolation functions described in section
<a class="reference internal" href="#ndimage-interpolation"><span class="std std-ref">Interpolation functions</span></a> apply pre-filtering by calling
<a class="reference internal" href="../reference/generated/scipy.ndimage.spline_filter.html#scipy.ndimage.spline_filter" title="scipy.ndimage.spline_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">spline_filter</span></code></a>, but they can be instructed not to do this by
setting the <em>prefilter</em> keyword equal to False. This is useful if more
than one interpolation operation is done on the same array. In this
case, it is more efficient to do the pre-filtering only once and use a
pre-filtered array as the input of the interpolation functions. The
following two functions implement the pre-filtering:</p>
<ul>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.spline_filter1d.html#scipy.ndimage.spline_filter1d" title="scipy.ndimage.spline_filter1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">spline_filter1d</span></code></a> function calculates a 1-D
spline filter along the given axis. An output array can optionally
be provided. The order of the spline must be larger than 1 and less
than 6.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.spline_filter.html#scipy.ndimage.spline_filter" title="scipy.ndimage.spline_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">spline_filter</span></code></a> function calculates a multidimensional
spline filter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The multidimensional filter is implemented as a sequence of
1-D spline filters. The intermediate arrays are
stored in the same data type as the output. Therefore, if an
output with a limited precision is requested, the results may be
imprecise because intermediate results may be stored with
insufficient precision. This can be prevented by specifying a
output type of high precision.</p>
</div>
</li>
</ul>
</section>
<section id="interpolation-boundary-handling">
<span id="ndimage-interpolation-modes"></span><h3>Interpolation boundary handling<a class="headerlink" href="#interpolation-boundary-handling" title="Permalink to this headline">¶</a></h3>
<p>The interpolation functions all employ spline interpolation to effect some
type of geometric transformation of the input array. This requires a
mapping of the output coordinates to the input coordinates, and
therefore, the possibility arises that input values outside the
boundaries may be needed. This problem is solved in the same way as
described in <a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a> for the multidimensional
filter functions. Therefore, these functions all support a <em>mode</em>
parameter that determines how the boundaries are handled, and a <em>cval</em>
parameter that gives a constant value in case that the ‘constant’ mode
is used. The behavior of all modes, including at non-integer locations is
illustrated below. Note the boundaries are not handled the same for all modes;
<em class="xref py py-obj">reflect</em> (aka <em class="xref py py-obj">grid-mirror</em>) and <em class="xref py py-obj">grid-wrap</em> involve symmetry or repetition
about a point that is half way between image samples (dashed vertical lines)
while modes <em class="xref py py-obj">mirror</em> and <em class="xref py py-obj">wrap</em> treat the image as if it’s extent ends exactly
at the first and last sample point rather than 0.5 samples past it.</p>
<figure class="align-default">
<img alt="../_images/plot_boundary_modes.png" class="plot-directive" src="../_images/plot_boundary_modes.png" />
</figure>
<p>The coordinates of image samples fall on integer sampling locations
in the range from 0 to <code class="docutils literal notranslate"><span class="pre">shape[i]</span> <span class="pre">-</span> <span class="pre">1</span></code> along each axis, <code class="docutils literal notranslate"><span class="pre">i</span></code>. The figure
below illustrates the interpolation of a point at location <code class="docutils literal notranslate"><span class="pre">(3.7,</span> <span class="pre">3.3)</span></code>
within an image of shape <code class="docutils literal notranslate"><span class="pre">(7,</span> <span class="pre">7)</span></code>. For an interpolation of order <code class="docutils literal notranslate"><span class="pre">n</span></code>,
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> samples are involved along each axis. The filled circles
illustrate the sampling locations involved in the interpolation of the value at
the location of the red x.</p>
<figure class="align-default">
<img alt="../_images/plot_interp_grid.png" class="plot-directive" src="../_images/plot_interp_grid.png" />
</figure>
</section>
<section id="id3">
<h3>Interpolation functions<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform" title="scipy.ndimage.geometric_transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">geometric_transform</span></code></a> function applies an arbitrary
geometric transform to the input. The given <em>mapping</em> function is
called at each point in the output to find the corresponding
coordinates in the input. <em>mapping</em> must be a callable object that
accepts a tuple of length equal to the output array rank and returns
the corresponding input coordinates as a tuple of length equal to
the input array rank. The output shape and output type can
optionally be provided. If not given, they are equal to the input
shape and type.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_func</span><span class="p">(</span><span class="n">output_coordinates</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">output_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">geometric_transform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift_func</span><span class="p">)</span>
<span class="go">array([[ 0.    ,  0.    ,  0.    ],</span>
<span class="go">       [ 0.    ,  1.3625,  2.7375],</span>
<span class="go">       [ 0.    ,  4.8125,  6.1875],</span>
<span class="go">       [ 0.    ,  8.2625,  9.6375]])</span>
</pre></div>
</div>
<p>Optionally, extra arguments can be defined and passed to the filter
function. The <em>extra_arguments</em> and <em>extra_keywords</em> arguments can
be used to pass a tuple of extra arguments and/or a dictionary of
named arguments that are passed to derivative at each call. For
example, we can pass the shifts in our example as arguments</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_func</span><span class="p">(</span><span class="n">output_coordinates</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">output_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s0</span><span class="p">,</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift_func</span><span class="p">,</span> <span class="n">extra_arguments</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">array([[ 0.    ,  0.    ,  0.    ],</span>
<span class="go">       [ 0.    ,  1.3625,  2.7375],</span>
<span class="go">       [ 0.    ,  4.8125,  6.1875],</span>
<span class="go">       [ 0.    ,  8.2625,  9.6375]])</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift_func</span><span class="p">,</span> <span class="n">extra_keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;s0&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;s1&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">})</span>
<span class="go">array([[ 0.    ,  0.    ,  0.    ],</span>
<span class="go">       [ 0.    ,  1.3625,  2.7375],</span>
<span class="go">       [ 0.    ,  4.8125,  6.1875],</span>
<span class="go">       [ 0.    ,  8.2625,  9.6375]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mapping function can also be written in C and passed using a
<a class="reference internal" href="../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable" title="scipy.LowLevelCallable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.LowLevelCallable</span></code></a>. See <a class="reference internal" href="#ndimage-ccallbacks"><span class="std std-ref">Extending scipy.ndimage in C</span></a> for more
information.</p>
</div>
</li>
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates" title="scipy.ndimage.map_coordinates"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_coordinates</span></code></a> applies an arbitrary coordinate
transformation using the given array of coordinates. The shape of
the output is derived from that of the coordinate array by dropping
the first axis. The parameter <em>coordinates</em> is used to find for each
point in the output the corresponding coordinates in the input. The
values of <em>coordinates</em> along the first axis are the coordinates in
the input array at which the output value is found. (See also the
numarray <em class="xref py py-obj">coordinates</em> function.) Since the coordinates may be non-
integer coordinates, the value of the input at these coordinates is
determined by spline interpolation of the requested order.</p>
<p>Here is an example that interpolates a 2D array at <code class="docutils literal notranslate"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2)</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[  0.,   1.,   2.],</span>
<span class="go">       [  3.,   4.,   5.],</span>
<span class="go">       [  6.,   7.,   8.],</span>
<span class="go">       [  9.,  10.,  11.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">map_coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">array([ 1.3625,  7.])</span>
</pre></div>
</div>
</li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.affine_transform.html#scipy.ndimage.affine_transform" title="scipy.ndimage.affine_transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">affine_transform</span></code></a> function applies an affine
transformation to the input array. The given transformation <em>matrix</em>
and <em>offset</em> are used to find for each point in the output the
corresponding coordinates in the input. The value of the input at
the calculated coordinates is determined by spline interpolation of
the requested order. The transformation <em>matrix</em> must be
2-D or can also be given as a 1-D sequence
or array. In the latter case, it is assumed that the matrix is
diagonal. A more efficient interpolation algorithm is then applied
that exploits the separability of the problem. The output shape and
output type can optionally be provided. If not given, they are equal
to the input shape and type.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.shift.html#scipy.ndimage.shift" title="scipy.ndimage.shift"><code class="xref py py-func docutils literal notranslate"><span class="pre">shift</span></code></a> function returns a shifted version of the input,
using spline interpolation of the requested <em>order</em>.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.zoom.html#scipy.ndimage.zoom" title="scipy.ndimage.zoom"><code class="xref py py-func docutils literal notranslate"><span class="pre">zoom</span></code></a> function returns a rescaled version of the input,
using spline interpolation of the requested <em>order</em>.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.rotate.html#scipy.ndimage.rotate" title="scipy.ndimage.rotate"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotate</span></code></a> function returns the input array rotated in the
plane defined by the two axes given by the parameter <em>axes</em>, using
spline interpolation of the requested <em>order</em>. The angle must be
given in degrees. If <em>reshape</em> is true, then the size of the output
array is adapted to contain the rotated input.</p></li>
</ul>
</section>
</section>
<section id="morphology">
<span id="ndimage-morphology"></span><h2>Morphology<a class="headerlink" href="#morphology" title="Permalink to this headline">¶</a></h2>
<section id="binary-morphology">
<span id="ndimage-binary-morphology"></span><h3>Binary morphology<a class="headerlink" href="#binary-morphology" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a> functions generates a binary
structuring element for use in binary morphology operations. The
<em>rank</em> of the structure must be provided. The size of the structure
that is returned is equal to three in each direction. The value of
each element is equal to one if the square of the Euclidean distance
from the element to the center is less than or equal to
<em>connectivity</em>. For instance, 2-D 4-connected and
8-connected structures are generated as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">generate_binary_structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[False,  True, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [False,  True, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[ True,  True,  True],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [ True,  True,  True]], dtype=bool)</span>
</pre></div>
</div>
</li>
</ul>
<p>Most binary morphology functions can be expressed in terms of the
basic operations erosion and dilation.</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.binary_erosion.html#scipy.ndimage.binary_erosion" title="scipy.ndimage.binary_erosion"><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_erosion</span></code></a> function implements binary erosion of
arrays of arbitrary rank with the given structuring element. The
origin parameter controls the placement of the structuring element,
as described in <a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If no structuring
element is provided, an element with connectivity equal to one is
generated using <a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a>. The
<em>border_value</em> parameter gives the value of the array outside
boundaries. The erosion is repeated <em>iterations</em> times. If
<em>iterations</em> is less than one, the erosion is repeated until the
result does not change anymore. If a <em>mask</em> array is given, only
those elements with a true value at the corresponding mask element
are modified at each iteration.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation" title="scipy.ndimage.binary_dilation"><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_dilation</span></code></a> function implements binary dilation of
arrays of arbitrary rank with the given structuring element. The
origin parameter controls the placement of the structuring element,
as described in <a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If no structuring
element is provided, an element with connectivity equal to one is
generated using <a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a>. The
<em>border_value</em> parameter gives the value of the array outside
boundaries. The dilation is repeated <em>iterations</em> times. If
<em>iterations</em> is less than one, the dilation is repeated until the
result does not change anymore. If a <em>mask</em> array is given, only
those elements with a true value at the corresponding mask element
are modified at each iteration.</p></li>
</ul>
<p>Here is an example of using <a class="reference internal" href="../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation" title="scipy.ndimage.binary_dilation"><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_dilation</span></code></a> to find all elements
that touch the border, by repeatedly dilating an empty array from
the border using the data array as the mask:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 0, 1, 0],</span>
<span class="go">       [0, 0, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">binary_dilation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">struct</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">border_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ True, False, False, False, False],</span>
<span class="go">       [ True,  True, False, False, False],</span>
<span class="go">       [False, False, False, False, False],</span>
<span class="go">       [False, False, False, False, False]], dtype=bool)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.binary_erosion.html#scipy.ndimage.binary_erosion" title="scipy.ndimage.binary_erosion"><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_erosion</span></code></a> and <a class="reference internal" href="../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation" title="scipy.ndimage.binary_dilation"><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_dilation</span></code></a> functions both
have an <em>iterations</em> parameter, which allows the erosion or dilation to
be repeated a number of times. Repeating an erosion or a dilation with
a given structure <em>n</em> times is equivalent to an erosion or a dilation
with a structure that is <em>n-1</em> times dilated with itself. A function
is provided that allows the calculation of a structure that is dilated
a number of times with itself:</p>
<ul>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.iterate_structure.html#scipy.ndimage.iterate_structure" title="scipy.ndimage.iterate_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterate_structure</span></code></a> function returns a structure by dilation
of the input structure <em>iteration</em> - 1 times with itself.</p>
<p>For instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span>
<span class="go">array([[False,  True, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [False,  True, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">iterate_structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterate_structure</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[False, False,  True, False, False],</span>
<span class="go">       [False,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True],</span>
<span class="go">       [False,  True,  True,  True, False],</span>
<span class="go">       [False, False,  True, False, False]], dtype=bool)</span>

<span class="go">If the origin of the original structure is equal to 0, then it is</span>
<span class="go">also equal to 0 for the iterated structure. If not, the origin</span>
<span class="go">must also be adapted if the equivalent of the *iterations*</span>
<span class="go">erosions or dilations must be achieved with the iterated</span>
<span class="go">structure. The adapted origin is simply obtained by multiplying</span>
<span class="go">with the number of iterations. For convenience, the</span>
<span class="go">:func:`iterate_structure` also returns the adapted origin if the</span>
<span class="go">*origin* parameter is not ``None``:</span>

<span class="go">.. code:: python</span>

<span class="go">   &gt;&gt;&gt; iterate_structure(struct, 2, -1)</span>
<span class="go">   (array([[False, False,  True, False, False],</span>
<span class="go">           [False,  True,  True,  True, False],</span>
<span class="go">           [ True,  True,  True,  True,  True],</span>
<span class="go">           [False,  True,  True,  True, False],</span>
<span class="go">           [False, False,  True, False, False]], dtype=bool), [-2, -2])</span>
</pre></div>
</div>
</li>
</ul>
<p>Other morphology operations can be defined in terms of erosion and
dilation. The following functions provide a few of these operations
for convenience:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.binary_opening.html#scipy.ndimage.binary_opening" title="scipy.ndimage.binary_opening"><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_opening</span></code></a> function implements binary opening of
arrays of arbitrary rank with the given structuring element. Binary
opening is equivalent to a binary erosion followed by a binary
dilation with the same structuring element. The origin parameter
controls the placement of the structuring element, as described in
<a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If no structuring element is
provided, an element with connectivity equal to one is generated
using <a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a>. The <em>iterations</em> parameter
gives the number of erosions that is performed followed by the same
number of dilations.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.binary_closing.html#scipy.ndimage.binary_closing" title="scipy.ndimage.binary_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_closing</span></code></a> function implements binary closing of
arrays of arbitrary rank with the given structuring element. Binary
closing is equivalent to a binary dilation followed by a binary
erosion with the same structuring element. The origin parameter
controls the placement of the structuring element, as described in
<a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If no structuring element is
provided, an element with connectivity equal to one is generated
using <a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a>. The <em>iterations</em> parameter
gives the number of dilations that is performed followed by the same
number of erosions.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.binary_fill_holes.html#scipy.ndimage.binary_fill_holes" title="scipy.ndimage.binary_fill_holes"><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_fill_holes</span></code></a> function is used to close holes in
objects in a binary image, where the structure defines the
connectivity of the holes. The origin parameter controls the
placement of the structuring element, as described in
<a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If no structuring element is
provided, an element with connectivity equal to one is generated
using <a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a>.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.binary_hit_or_miss.html#scipy.ndimage.binary_hit_or_miss" title="scipy.ndimage.binary_hit_or_miss"><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_hit_or_miss</span></code></a> function implements a binary
hit-or-miss transform of arrays of arbitrary rank with the given
structuring elements. The hit-or-miss transform is calculated by
erosion of the input with the first structure, erosion of the
logical <em>not</em> of the input with the second structure, followed by
the logical <em>and</em> of these two erosions. The origin parameters
control the placement of the structuring elements, as described in
<a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>. If <em>origin2</em> equals <code class="docutils literal notranslate"><span class="pre">None</span></code>, it is set
equal to the <em>origin1</em> parameter. If the first structuring element
is not provided, a structuring element with connectivity equal to
one is generated using <a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a>. If
<em>structure2</em> is not provided, it is set equal to the logical <em>not</em>
of <em>structure1</em>.</p></li>
</ul>
</section>
<section id="grey-scale-morphology">
<span id="ndimage-grey-morphology"></span><h3>Grey-scale morphology<a class="headerlink" href="#grey-scale-morphology" title="Permalink to this headline">¶</a></h3>
<p>Grey-scale morphology operations are the equivalents of binary
morphology operations that operate on arrays with arbitrary values.
Below, we describe the grey-scale equivalents of erosion, dilation,
opening and closing. These operations are implemented in a similar
fashion as the filters described in <a class="reference internal" href="#ndimage-filter-functions"><span class="std std-ref">Filter functions</span></a>,
and we refer to this section for the description of filter kernels and
footprints, and the handling of array borders. The grey-scale
morphology operations optionally take a <em>structure</em> parameter that
gives the values of the structuring element. If this parameter is not
given, the structuring element is assumed to be flat with a value equal
to zero. The shape of the structure can optionally be defined by the
<em>footprint</em> parameter. If this parameter is not given, the structure
is assumed to be rectangular, with sizes equal to the dimensions of
the <em>structure</em> array, or by the <em>size</em> parameter if <em>structure</em> is
not given. The <em>size</em> parameter is only used if both <em>structure</em> and
<em>footprint</em> are not given, in which case the structuring element is
assumed to be rectangular and flat with the dimensions given by
<em>size</em>. The <em>size</em> parameter, if provided, must be a sequence of sizes
or a single number in which case the size of the filter is assumed to
be equal along each axis. The <em>footprint</em> parameter, if provided, must
be an array that defines the shape of the kernel by its non-zero
elements.</p>
<p>Similarly to binary erosion and dilation, there are operations for
grey-scale erosion and dilation:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.grey_erosion.html#scipy.ndimage.grey_erosion" title="scipy.ndimage.grey_erosion"><code class="xref py py-func docutils literal notranslate"><span class="pre">grey_erosion</span></code></a> function calculates a multidimensional
grey-scale erosion.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.grey_dilation.html#scipy.ndimage.grey_dilation" title="scipy.ndimage.grey_dilation"><code class="xref py py-func docutils literal notranslate"><span class="pre">grey_dilation</span></code></a> function calculates a multidimensional
grey-scale dilation.</p></li>
</ul>
<p>Grey-scale opening and closing operations can be defined similarly to
their binary counterparts:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.grey_opening.html#scipy.ndimage.grey_opening" title="scipy.ndimage.grey_opening"><code class="xref py py-func docutils literal notranslate"><span class="pre">grey_opening</span></code></a> function implements grey-scale opening of
arrays of arbitrary rank. Grey-scale opening is equivalent to a
grey-scale erosion followed by a grey-scale dilation.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.grey_closing.html#scipy.ndimage.grey_closing" title="scipy.ndimage.grey_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">grey_closing</span></code></a> function implements grey-scale closing of
arrays of arbitrary rank. Grey-scale opening is equivalent to a
grey-scale dilation followed by a grey-scale erosion.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.morphological_gradient.html#scipy.ndimage.morphological_gradient" title="scipy.ndimage.morphological_gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">morphological_gradient</span></code></a> function implements a grey-scale
morphological gradient of arrays of arbitrary rank. The grey-scale
morphological gradient is equal to the difference of a grey-scale
dilation and a grey-scale erosion.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.morphological_laplace.html#scipy.ndimage.morphological_laplace" title="scipy.ndimage.morphological_laplace"><code class="xref py py-func docutils literal notranslate"><span class="pre">morphological_laplace</span></code></a> function implements a grey-scale
morphological laplace of arrays of arbitrary rank. The grey-scale
morphological laplace is equal to the sum of a grey-scale dilation
and a grey-scale erosion minus twice the input.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.white_tophat.html#scipy.ndimage.white_tophat" title="scipy.ndimage.white_tophat"><code class="xref py py-func docutils literal notranslate"><span class="pre">white_tophat</span></code></a> function implements a white top-hat filter
of arrays of arbitrary rank. The white top-hat is equal to the
difference of the input and a grey-scale opening.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.black_tophat.html#scipy.ndimage.black_tophat" title="scipy.ndimage.black_tophat"><code class="xref py py-func docutils literal notranslate"><span class="pre">black_tophat</span></code></a> function implements a black top-hat filter
of arrays of arbitrary rank. The black top-hat is equal to the
difference of a grey-scale closing and the input.</p></li>
</ul>
</section>
</section>
<section id="distance-transforms">
<span id="ndimage-distance-transforms"></span><h2>Distance transforms<a class="headerlink" href="#distance-transforms" title="Permalink to this headline">¶</a></h2>
<p>Distance transforms are used to calculate the minimum distance from
each element of an object to the background. The following functions
implement distance transforms for three different distance metrics:
Euclidean, city block, and chessboard distances.</p>
<ul>
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.distance_transform_cdt.html#scipy.ndimage.distance_transform_cdt" title="scipy.ndimage.distance_transform_cdt"><code class="xref py py-func docutils literal notranslate"><span class="pre">distance_transform_cdt</span></code></a> uses a chamfer type
algorithm to calculate the distance transform of the input, by
replacing each object element (defined by values larger than zero)
with the shortest distance to the background (all non-object
elements). The structure determines the type of chamfering that is
done. If the structure is equal to ‘cityblock’, a structure is
generated using <a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a> with a squared
distance equal to 1. If the structure is equal to ‘chessboard’, a
structure is generated using <a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a> with
a squared distance equal to the rank of the array. These choices
correspond to the common interpretations of the city block and the
chessboard distance metrics in two dimensions.</p>
<p>In addition to the distance transform, the feature transform can be
calculated. In this case, the index of the closest background element
is returned along the first axis of the result. The
<em>return_distances</em>, and <em>return_indices</em> flags can be used to
indicate if the distance transform, the feature transform, or both
must be returned.</p>
<p>The <em>distances</em> and <em>indices</em> arguments can be used to give optional
output arrays that must be of the correct size and type (both
<code class="docutils literal notranslate"><span class="pre">numpy.int32</span></code>). The basics of the algorithm used to implement this
function are described in <a class="footnote-reference brackets" href="#id9" id="id4">2</a>.</p>
</li>
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt" title="scipy.ndimage.distance_transform_edt"><code class="xref py py-func docutils literal notranslate"><span class="pre">distance_transform_edt</span></code></a> calculates the exact
Euclidean distance transform of the input, by replacing each object
element (defined by values larger than zero) with the shortest
Euclidean distance to the background (all non-object elements).</p>
<p>In addition to the distance transform, the feature transform can be
calculated. In this case, the index of the closest background element
is returned along the first axis of the result. The
<em>return_distances</em> and <em>return_indices</em> flags can be used to
indicate if the distance transform, the feature transform, or both
must be returned.</p>
<p>Optionally, the sampling along each axis can be given by the
<em>sampling</em> parameter, which should be a sequence of length equal to
the input rank, or a single number in which the sampling is assumed
to be equal along all axes.</p>
<p>The <em>distances</em> and <em>indices</em> arguments can be used to give optional
output arrays that must be of the correct size and type
(<code class="docutils literal notranslate"><span class="pre">numpy.float64</span></code> and <code class="docutils literal notranslate"><span class="pre">numpy.int32</span></code>).The algorithm used to
implement this function is described in <a class="footnote-reference brackets" href="#id10" id="id5">3</a>.</p>
</li>
<li><p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.distance_transform_bf.html#scipy.ndimage.distance_transform_bf" title="scipy.ndimage.distance_transform_bf"><code class="xref py py-func docutils literal notranslate"><span class="pre">distance_transform_bf</span></code></a> uses a brute-force
algorithm to calculate the distance transform of the input, by
replacing each object element (defined by values larger than zero)
with the shortest distance to the background (all non-object
elements). The metric must be one of “euclidean”, “cityblock”, or
“chessboard”.</p>
<p>In addition to the distance transform, the feature transform can be
calculated. In this case, the index of the closest background element
is returned along the first axis of the result. The
<em>return_distances</em> and <em>return_indices</em> flags can be used to
indicate if the distance transform, the feature transform, or both
must be returned.</p>
<p>Optionally, the sampling along each axis can be given by the
<em>sampling</em> parameter, which should be a sequence of length equal to
the input rank, or a single number in which the sampling is assumed
to be equal along all axes. This parameter is only used in the case
of the Euclidean distance transform.</p>
<p>The <em>distances</em> and <em>indices</em> arguments can be used to give optional
output arrays that must be of the correct size and type
(<code class="docutils literal notranslate"><span class="pre">numpy.float64</span></code> and <code class="docutils literal notranslate"><span class="pre">numpy.int32</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function uses a slow brute-force algorithm, the function
<a class="reference internal" href="../reference/generated/scipy.ndimage.distance_transform_cdt.html#scipy.ndimage.distance_transform_cdt" title="scipy.ndimage.distance_transform_cdt"><code class="xref py py-func docutils literal notranslate"><span class="pre">distance_transform_cdt</span></code></a> can be used to more efficiently
calculate city block and chessboard distance transforms. The
function <a class="reference internal" href="../reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt" title="scipy.ndimage.distance_transform_edt"><code class="xref py py-func docutils literal notranslate"><span class="pre">distance_transform_edt</span></code></a> can be used to more
efficiently calculate the exact Euclidean distance transform.</p>
</div>
</li>
</ul>
</section>
<section id="segmentation-and-labeling">
<h2>Segmentation and labeling<a class="headerlink" href="#segmentation-and-labeling" title="Permalink to this headline">¶</a></h2>
<p>Segmentation is the process of separating objects of interest from
the background. The most simple approach is, probably, intensity
thresholding, which is easily done with <a class="reference external" href="https://numpy.org/devdocs/reference/index.html#module-numpy" title="(in NumPy v1.21.dev0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code></a> functions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[0, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 1, 0]])</span>
</pre></div>
</div>
<p>The result is a binary image, in which the individual objects still
need to be identified and labeled. The function <a class="reference internal" href="../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label" title="scipy.ndimage.label"><code class="xref py py-func docutils literal notranslate"><span class="pre">label</span></code></a>
generates an array where each object is assigned a unique number:</p>
<ul>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label" title="scipy.ndimage.label"><code class="xref py py-func docutils literal notranslate"><span class="pre">label</span></code></a> function generates an array where the objects in
the input are labeled with an integer index. It returns a tuple
consisting of the array of object labels and the number of objects
found, unless the <em>output</em> parameter is given, in which case only
the number of objects is returned. The connectivity of the objects
is defined by a structuring element. For instance, in 2D
using a 4-connected structuring element gives:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="go">(array([[0, 1, 1, 0, 0, 0],</span>
<span class="go">        [0, 1, 1, 0, 2, 0],</span>
<span class="go">        [0, 0, 0, 2, 2, 2],</span>
<span class="go">        [0, 0, 0, 0, 2, 0]]), 2)</span>
</pre></div>
</div>
<p>These two objects are not connected because there is no way in which
we can place the structuring element, such that it overlaps with both
objects. However, an 8-connected structuring element results in only
a single object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 1, 0]])</span>
</pre></div>
</div>
<p>If no structuring element is provided, one is generated by calling
<a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a> (see
<a class="reference internal" href="#ndimage-binary-morphology"><span class="std std-ref">Binary morphology</span></a>) using a connectivity of one (which
in 2D is the 4-connected structure of the first example). The input
can be of any type, any value not equal to zero is taken to be part
of an object. This is useful if you need to ‘re-label’ an array of
object indices, for instance, after removing unwanted objects. Just
apply the label function again to the index array. For instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">label</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span>
<span class="go">array([1, 0, 2, 0, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span>
<span class="go">array([1, 0, 0, 0, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([1, 0, 0, 0, 2])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The structuring element used by <a class="reference internal" href="../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label" title="scipy.ndimage.label"><code class="xref py py-func docutils literal notranslate"><span class="pre">label</span></code></a> is assumed to be
symmetric.</p>
</div>
</li>
</ul>
<p>There is a large number of other approaches for segmentation, for
instance, from an estimation of the borders of the objects that can be
obtained by derivative filters. One such approach is
watershed segmentation. The function <a class="reference internal" href="../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift" title="scipy.ndimage.watershed_ift"><code class="xref py py-func docutils literal notranslate"><span class="pre">watershed_ift</span></code></a> generates
an array where each object is assigned a unique label, from an array
that localizes the object borders, generated, for instance, by a
gradient magnitude filter. It uses an array containing initial markers
for the objects:</p>
<ul>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift" title="scipy.ndimage.watershed_ift"><code class="xref py py-func docutils literal notranslate"><span class="pre">watershed_ift</span></code></a> function applies a watershed from markers
algorithm, using Image Foresting Transform, as described in
<a class="footnote-reference brackets" href="#id11" id="id6">4</a>.</p></li>
<li><p>The inputs of this function are the array to which the transform is
applied, and an array of markers that designate the objects by a
unique label, where any non-zero value is a marker. For instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">watershed_ift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">watershed_ift</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">markers</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 2, 2, 2, 2, 2, 1],</span>
<span class="go">       [1, 2, 2, 2, 2, 2, 1],</span>
<span class="go">       [1, 2, 2, 2, 2, 2, 1],</span>
<span class="go">       [1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1]], dtype=int8)</span>
</pre></div>
</div>
<p>Here, two markers were used to designate an object (<em>marker</em> = 2) and
the background (<em>marker</em> = 1). The order in which these are
processed is arbitrary: moving the marker for the background to the
lower-right corner of the array yields a different result:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">watershed_ift</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">markers</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1]], dtype=int8)</span>
</pre></div>
</div>
<p>The result is that the object (<em>marker</em> = 2) is smaller because the
second marker was processed earlier. This may not be the desired
effect if the first marker was supposed to designate a background
object. Therefore, <a class="reference internal" href="../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift" title="scipy.ndimage.watershed_ift"><code class="xref py py-func docutils literal notranslate"><span class="pre">watershed_ift</span></code></a> treats markers with a
negative value explicitly as background markers and processes them
after the normal markers. For instance, replacing the first marker
by a negative marker gives a result similar to the first example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">markers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">watershed_ift</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">markers</span><span class="p">)</span>
<span class="go">array([[-1, -1, -1, -1, -1, -1, -1],</span>
<span class="go">       [-1, -1,  2,  2,  2, -1, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1, -1,  2,  2,  2, -1, -1],</span>
<span class="go">       [-1, -1, -1, -1, -1, -1, -1]], dtype=int8)</span>
</pre></div>
</div>
<p>The connectivity of the objects is defined by a structuring
element. If no structuring element is provided, one is generated by
calling <a class="reference internal" href="../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure" title="scipy.ndimage.generate_binary_structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_binary_structure</span></code></a> (see
<a class="reference internal" href="#ndimage-binary-morphology"><span class="std std-ref">Binary morphology</span></a>) using a connectivity of one (which
in 2D is a 4-connected structure.) For example, using an 8-connected
structure with the last example yields a different object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">watershed_ift</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">markers</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">structure</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">array([[-1, -1, -1, -1, -1, -1, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1,  2,  2,  2,  2,  2, -1],</span>
<span class="go">       [-1, -1, -1, -1, -1, -1, -1]], dtype=int8)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implementation of <a class="reference internal" href="../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift" title="scipy.ndimage.watershed_ift"><code class="xref py py-func docutils literal notranslate"><span class="pre">watershed_ift</span></code></a> limits the data types
of the input to <code class="docutils literal notranslate"><span class="pre">numpy.uint8</span></code> and <code class="docutils literal notranslate"><span class="pre">numpy.uint16</span></code>.</p>
</div>
</li>
</ul>
</section>
<section id="object-measurements">
<span id="ndimage-object-measurements"></span><h2>Object measurements<a class="headerlink" href="#object-measurements" title="Permalink to this headline">¶</a></h2>
<p>Given an array of labeled objects, the properties of the individual
objects can be measured. The <a class="reference internal" href="../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects" title="scipy.ndimage.find_objects"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_objects</span></code></a> function can be used
to generate a list of slices that for each object, give the
smallest sub-array that fully contains the object:</p>
<ul>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects" title="scipy.ndimage.find_objects"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_objects</span></code></a> function finds all objects in a labeled
array and returns a list of slices that correspond to the smallest
regions in the array that contains the object.</p>
<p>For instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">find_objects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">find_objects</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="go">array([[0, 1, 0],</span>
<span class="go">       [1, 1, 1],</span>
<span class="go">       [0, 1, 0]])</span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects" title="scipy.ndimage.find_objects"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_objects</span></code></a> returns slices for all objects,
unless the <em>max_label</em> parameter is larger then zero, in which case
only the first <em>max_label</em> objects are returned. If an index is
missing in the <em>label</em> array, <code class="docutils literal notranslate"><span class="pre">None</span></code> is return instead of a
slice. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">find_objects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_objects</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">max_label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[(slice(0, 1, None),), None, (slice(2, 3, None),)]</span>
</pre></div>
</div>
</li>
</ul>
<p>The list of slices generated by <a class="reference internal" href="../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects" title="scipy.ndimage.find_objects"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_objects</span></code></a> is useful to find
the position and dimensions of the objects in the array, but can also
be used to perform measurements on the individual objects. Say, we want
to find the sum of the intensities of an object in image:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">slices</span> <span class="o">=</span> <span class="n">find_objects</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we can calculate the sum of the elements in the second object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">80</span>
</pre></div>
</div>
<p>That is, however, not particularly efficient and may also be more
complicated for other types of measurements. Therefore, a few
measurements functions are defined that accept the array of object
labels and the index of the object to be measured. For instance,
calculating the sum of the intensities can be done by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="nb">sum</span> <span class="k">as</span> <span class="n">ndi_sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndi_sum</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">80</span>
</pre></div>
</div>
<p>For large arrays and small objects, it is more efficient to call the
measurement functions after slicing the array:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndi_sum</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">labels</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">80</span>
</pre></div>
</div>
<p>Alternatively, we can do the measurements for a number of labels with
a single function call, returning a list of results. For instance, to
measure the sum of the values of the background and the second object
in our example, we give a list of labels:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ndi_sum</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([178.0, 80.0])</span>
</pre></div>
</div>
<p>The measurement functions described below all support the <em>index</em>
parameter to indicate which object(s) should be measured. The default
value of <em>index</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>. This indicates that all elements where the
label is larger than zero should be treated as a single object and
measured. Thus, in this case the <em>labels</em> array is treated as a mask
defined by the elements that are larger than zero. If <em>index</em> is a
number or a sequence of numbers it gives the labels of the objects
that are measured. If <em>index</em> is a sequence, a list of the results is
returned. Functions that return more than one result return their
result as a tuple if <em>index</em> is a single number, or as a tuple of
lists if <em>index</em> is a sequence.</p>
<ul class="simple">
<li><p>The <a class="reference external" href="https://docs.python.org/dev/library/functions.html#sum" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum</span></code></a> function calculates the sum of the elements of the
object with label(s) given by <em>index</em>, using the <em>labels</em> array for
the object labels. If <em>index</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements with a
non-zero label value are treated as a single object. If <em>label</em> is
<code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the calculation.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.mean.html#scipy.ndimage.mean" title="scipy.ndimage.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean</span></code></a> function calculates the mean of the elements of the
object with label(s) given by <em>index</em>, using the <em>labels</em> array for
the object labels. If <em>index</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements with a
non-zero label value are treated as a single object. If <em>label</em> is
<code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the calculation.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.variance.html#scipy.ndimage.variance" title="scipy.ndimage.variance"><code class="xref py py-func docutils literal notranslate"><span class="pre">variance</span></code></a> function calculates the variance of the
elements of the object with label(s) given by <em>index</em>, using the
<em>labels</em> array for the object labels. If <em>index</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all
elements with a non-zero label value are treated as a single
object. If <em>label</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of <em>input</em> are used in
the calculation.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.standard_deviation.html#scipy.ndimage.standard_deviation" title="scipy.ndimage.standard_deviation"><code class="xref py py-func docutils literal notranslate"><span class="pre">standard_deviation</span></code></a> function calculates the standard
deviation of the elements of the object with label(s) given by
<em>index</em>, using the <em>labels</em> array for the object labels. If <em>index</em>
is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements with a non-zero label value are treated as
a single object. If <em>label</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of <em>input</em> are
used in the calculation.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.minimum.html#scipy.ndimage.minimum" title="scipy.ndimage.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum</span></code></a> function calculates the minimum of the elements
of the object with label(s) given by <em>index</em>, using the <em>labels</em>
array for the object labels. If <em>index</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements
with a non-zero label value are treated as a single object. If
<em>label</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the
calculation.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.maximum.html#scipy.ndimage.maximum" title="scipy.ndimage.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum</span></code></a> function calculates the maximum of the elements
of the object with label(s) given by <em>index</em>, using the <em>labels</em>
array for the object labels. If <em>index</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements
with a non-zero label value are treated as a single object. If
<em>label</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the
calculation.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.minimum_position.html#scipy.ndimage.minimum_position" title="scipy.ndimage.minimum_position"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum_position</span></code></a> function calculates the position of the
minimum of the elements of the object with label(s) given by
<em>index</em>, using the <em>labels</em> array for the object labels. If <em>index</em>
is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements with a non-zero label value are treated as
a single object. If <em>label</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of <em>input</em> are
used in the calculation.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.maximum_position.html#scipy.ndimage.maximum_position" title="scipy.ndimage.maximum_position"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum_position</span></code></a> function calculates the position of the
maximum of the elements of the object with label(s) given by
<em>index</em>, using the <em>labels</em> array for the object labels. If <em>index</em>
is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements with a non-zero label value are treated as
a single object. If <em>label</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of <em>input</em> are
used in the calculation.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.extrema.html#scipy.ndimage.extrema" title="scipy.ndimage.extrema"><code class="xref py py-func docutils literal notranslate"><span class="pre">extrema</span></code></a> function calculates the minimum, the maximum,
and their positions, of the elements of the object with label(s)
given by <em>index</em>, using the <em>labels</em> array for the object labels. If
<em>index</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements with a non-zero label value are
treated as a single object. If <em>label</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of
<em>input</em> are used in the calculation. The result is a tuple giving
the minimum, the maximum, the position of the minimum, and the
position of the maximum. The result is the same as a tuple formed by
the results of the functions <em>minimum</em>, <em>maximum</em>,
<em>minimum_position</em>, and <em>maximum_position</em> that are described above.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.center_of_mass.html#scipy.ndimage.center_of_mass" title="scipy.ndimage.center_of_mass"><code class="xref py py-func docutils literal notranslate"><span class="pre">center_of_mass</span></code></a> function calculates the center of mass of
the object with label(s) given by <em>index</em>, using the <em>labels</em>
array for the object labels. If <em>index</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements
with a non-zero label value are treated as a single object. If
<em>label</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the
calculation.</p></li>
<li><p>The <a class="reference internal" href="../reference/generated/scipy.ndimage.histogram.html#scipy.ndimage.histogram" title="scipy.ndimage.histogram"><code class="xref py py-func docutils literal notranslate"><span class="pre">histogram</span></code></a> function calculates a histogram of the
object with label(s) given by <em>index</em>, using the <em>labels</em> array for
the object labels. If <em>index</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements with a
non-zero label value are treated as a single object. If <em>label</em> is
<code class="docutils literal notranslate"><span class="pre">None</span></code>, all elements of <em>input</em> are used in the calculation.
Histograms are defined by their minimum (<em>min</em>), maximum (<em>max</em>), and
the number of bins (<em>bins</em>). They are returned as 1-D
arrays of type <code class="docutils literal notranslate"><span class="pre">numpy.int32</span></code>.</p></li>
</ul>
</section>
<section id="extending-scipy-ndimage-in-c">
<span id="ndimage-ccallbacks"></span><h2>Extending <a class="reference internal" href="../reference/ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.ndimage</span></code></a> in C<a class="headerlink" href="#extending-scipy-ndimage-in-c" title="Permalink to this headline">¶</a></h2>
<p>A few functions in <a class="reference internal" href="../reference/ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.ndimage</span></code></a> take a callback argument. This
can be either a python function or a <a class="reference internal" href="../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable" title="scipy.LowLevelCallable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.LowLevelCallable</span></code></a> containing a
pointer to a C function. Using a C function will generally be more
efficient, since it avoids the overhead of calling a python function on
many elements of an array. To use a C function, you must write a C
extension that contains the callback function and a Python function
that returns a <a class="reference internal" href="../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable" title="scipy.LowLevelCallable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.LowLevelCallable</span></code></a> containing a pointer to the
callback.</p>
<p>An example of a function that supports callbacks is
<a class="reference internal" href="../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform" title="scipy.ndimage.geometric_transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">geometric_transform</span></code></a>, which accepts a callback function that
defines a mapping from all output coordinates to corresponding
coordinates in the input array. Consider the following python example,
which uses <a class="reference internal" href="../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform" title="scipy.ndimage.geometric_transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">geometric_transform</span></code></a> to implement a shift function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>

<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">output_coordinates</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
    <span class="n">input_coordinates</span> <span class="o">=</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span><span class="p">,</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span>
    <span class="k">return</span> <span class="n">input_coordinates</span>

<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">extra_arguments</span><span class="o">=</span><span class="p">(</span><span class="n">shift</span><span class="p">,)))</span>
</pre></div>
</div>
<p>We can also implement the callback function with the following C code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* example.c */</span>

<span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numpy/npy_common.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">_transform</span><span class="p">(</span><span class="n">npy_intp</span> <span class="o">*</span><span class="n">output_coordinates</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">input_coordinates</span><span class="p">,</span>
           <span class="kt">int</span> <span class="n">output_rank</span><span class="p">,</span> <span class="kt">int</span> <span class="n">input_rank</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">npy_intp</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">shift</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input_rank</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">input_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">transform_signature</span> <span class="o">=</span> <span class="s">&quot;int (npy_intp *, double *, int, int, void *)&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">py_get_transform</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">))</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">PyCapsule_New</span><span class="p">(</span><span class="n">_transform</span><span class="p">,</span> <span class="n">transform_signature</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">ExampleMethods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;get_transform&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">py_get_transform</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* Initialize the module */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="nc">PyModuleDef</span> <span class="n">example</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;example&quot;</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="mi">-1</span><span class="p">,</span>
    <span class="n">ExampleMethods</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_example</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">example</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>More information on writing Python extension modules can be found
<a class="reference external" href="https://docs.python.org/2/extending/extending.html">here</a>. If the C code is in the file <code class="docutils literal notranslate"><span class="pre">example.c</span></code>, then it can be
compiled with the following <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">shift</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;example&#39;</span><span class="p">,</span>
                  <span class="p">[</span><span class="s1">&#39;example.c&#39;</span><span class="p">],</span>
                  <span class="n">include_dirs</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">get_include</span><span class="p">()]</span>
<span class="p">)</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;example&#39;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">shift</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>and now running the script</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">LowLevelCallable</span>

<span class="kn">from</span> <span class="nn">example</span> <span class="kn">import</span> <span class="n">get_transform</span>

<span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">user_data</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">user_data</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span>
<span class="n">callback</span> <span class="o">=</span> <span class="n">LowLevelCallable</span><span class="p">(</span><span class="n">get_transform</span><span class="p">(),</span> <span class="n">ptr</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
</pre></div>
</div>
<p>produces the same result as the original python script.</p>
<p>In the C version, <code class="docutils literal notranslate"><span class="pre">_transform</span></code> is the callback function and the
parameters <code class="docutils literal notranslate"><span class="pre">output_coordinates</span></code> and <code class="docutils literal notranslate"><span class="pre">input_coordinates</span></code> play the
same role as they do in the python version, while <code class="docutils literal notranslate"><span class="pre">output_rank</span></code> and
<code class="docutils literal notranslate"><span class="pre">input_rank</span></code> provide the equivalents of <code class="docutils literal notranslate"><span class="pre">len(output_coordinates)</span></code>
and <code class="docutils literal notranslate"><span class="pre">len(input_coordinates)</span></code>. The variable <code class="docutils literal notranslate"><span class="pre">shift</span></code> is passed
through <code class="docutils literal notranslate"><span class="pre">user_data</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">extra_arguments</span></code>. Finally, the C callback function returns an integer
status, which is one upon success and zero otherwise.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">py_transform</span></code> wraps the callback function in a
<a class="reference external" href="https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule" title="(in Python v3.11)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCapsule</span></code></a>. The main steps are:</p>
<ul>
<li><p>Initialize a <a class="reference external" href="https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule" title="(in Python v3.11)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCapsule</span></code></a>. The first argument is a pointer to
the callback function.</p></li>
<li><p>The second argument is the function signature, which must match exactly
the one expected by <a class="reference internal" href="../reference/ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ndimage</span></code></a>.</p></li>
<li><p>Above, we used  <a class="reference internal" href="../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable" title="scipy.LowLevelCallable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.LowLevelCallable</span></code></a> to specify <code class="docutils literal notranslate"><span class="pre">user_data</span></code>
that we generated with <a class="reference external" href="https://docs.python.org/dev/library/ctypes.html#module-ctypes" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></a>.</p>
<p>A different approach would be to supply the data in the capsule context,
that can be set by <em class="xref py py-obj">PyCapsule_SetContext</em> and omit specifying
<code class="docutils literal notranslate"><span class="pre">user_data</span></code> in <a class="reference internal" href="../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable" title="scipy.LowLevelCallable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.LowLevelCallable</span></code></a>. However, in this approach we would
need to deal with allocation/freeing of the data — freeing the data
after the capsule has been destroyed can be done by specifying a non-NULL
callback function in the third argument of <em class="xref py py-obj">PyCapsule_New</em>.</p>
</li>
</ul>
<p>C callback functions for <a class="reference internal" href="../reference/ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ndimage</span></code></a> all follow this scheme. The
next section lists the <a class="reference internal" href="../reference/ndimage.html#module-scipy.ndimage" title="scipy.ndimage"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ndimage</span></code></a> functions that accept a C
callback function and gives the prototype of the function.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The functions that support low-level callback arguments are:</p>
<p><a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter" title="scipy.ndimage.generic_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generic_filter</span></code></a>, <a class="reference internal" href="../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d" title="scipy.ndimage.generic_filter1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generic_filter1d</span></code></a>, <a class="reference internal" href="../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform" title="scipy.ndimage.geometric_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geometric_transform</span></code></a></p>
</div>
<p>Below, we show alternative ways to write the code, using <a class="reference external" href="https://numba.pydata.org/">Numba</a>, <a class="reference external" href="https://cython.org/">Cython</a>,
<a class="reference external" href="https://docs.python.org/3/library/ctypes.html">ctypes</a>, or <a class="reference external" href="https://cffi.readthedocs.io/">cffi</a> instead of writing wrapper code in C.</p>
<p class="rubric">Numba</p>
<p><a class="reference external" href="https://numba.pydata.org/">Numba</a> provides a way to write low-level functions easily in Python.
We can write the above using Numba as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># example.py</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">LowLevelCallable</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cfunc</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">carray</span>

<span class="nd">@cfunc</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">intc</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">CPointer</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span>
                  <span class="n">types</span><span class="o">.</span><span class="n">CPointer</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">double</span><span class="p">),</span>
                  <span class="n">types</span><span class="o">.</span><span class="n">intc</span><span class="p">,</span>
                  <span class="n">types</span><span class="o">.</span><span class="n">intc</span><span class="p">,</span>
                  <span class="n">types</span><span class="o">.</span><span class="n">voidptr</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">output_coordinates_ptr</span><span class="p">,</span> <span class="n">input_coordinates_ptr</span><span class="p">,</span>
              <span class="n">output_rank</span><span class="p">,</span> <span class="n">input_rank</span><span class="p">,</span> <span class="n">user_data</span><span class="p">):</span>
    <span class="n">input_coordinates</span> <span class="o">=</span> <span class="n">carray</span><span class="p">(</span><span class="n">input_coordinates_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">input_rank</span><span class="p">,))</span>
    <span class="n">output_coordinates</span> <span class="o">=</span> <span class="n">carray</span><span class="p">(</span><span class="n">output_coordinates_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">output_rank</span><span class="p">,))</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">carray</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">types</span><span class="o">.</span><span class="n">double</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">input_rank</span><span class="p">):</span>
        <span class="n">input_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span>

    <span class="k">return</span> <span class="mi">1</span>

<span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="c1"># Then call the function</span>
<span class="n">user_data</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">user_data</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span>
<span class="n">callback</span> <span class="o">=</span> <span class="n">LowLevelCallable</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">ctypes</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>

<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric">Cython</p>
<p>Functionally the same code as above can be written in Cython with
somewhat less boilerplate as follows:</p>
<div class="highlight-cython notranslate"><div class="highlight"><pre><span></span><span class="c"># example.pyx</span>

<span class="k">from</span> <span class="nn">numpy</span> <span class="k">cimport</span> <span class="n">npy_intp</span> <span class="k">as</span> <span class="n">intp</span>

<span class="k">cdef</span> <span class="kr">api</span> <span class="kt">int</span> <span class="nf">transform</span><span class="p">(</span><span class="n">intp</span> <span class="o">*</span><span class="n">output_coordinates</span><span class="p">,</span> <span class="n">double</span> <span class="o">*</span><span class="n">input_coordinates</span><span class="p">,</span>
                       <span class="nb">int</span> <span class="n">output_rank</span><span class="p">,</span> <span class="nb">int</span> <span class="n">input_rank</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">intp</span> <span class="nf">i</span>
    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">shift</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">double</span> <span class="o">*&gt;</span><span class="n">user_data</span><span class="p">)[</span><span class="mf">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">input_rank</span><span class="p">):</span>
        <span class="n">input_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span>
    <span class="k">return</span> <span class="mf">1</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># script.py</span>

<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">LowLevelCallable</span>

<span class="kn">import</span> <span class="nn">example</span>

<span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">user_data</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">user_data</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span>
<span class="n">callback</span> <span class="o">=</span> <span class="n">LowLevelCallable</span><span class="o">.</span><span class="n">from_cython</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric">cffi</p>
<p>With <a class="reference external" href="https://cffi.readthedocs.io/">cffi</a>, you can interface with a C function residing in a shared
library (DLL). First, we need to write the shared library, which we do
in C — this example is for Linux/OSX:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">  example.c</span>
<span class="cm">  Needs to be compiled with &quot;gcc -std=c99 -shared -fPIC -o example.so example.c&quot;</span>
<span class="cm">  or similar</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">_transform</span><span class="p">(</span><span class="kt">intptr_t</span> <span class="o">*</span><span class="n">output_coordinates</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">input_coordinates</span><span class="p">,</span>
           <span class="kt">int</span> <span class="n">output_rank</span><span class="p">,</span> <span class="kt">int</span> <span class="n">input_rank</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">shift</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input_rank</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">input_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The Python code calling the library is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">LowLevelCallable</span>
<span class="kn">import</span> <span class="nn">cffi</span>

<span class="c1"># Construct the FFI object, and copypaste the function declaration</span>
<span class="n">ffi</span> <span class="o">=</span> <span class="n">cffi</span><span class="o">.</span><span class="n">FFI</span><span class="p">()</span>
<span class="n">ffi</span><span class="o">.</span><span class="n">cdef</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">int _transform(intptr_t *output_coordinates, double *input_coordinates,</span>
<span class="s2">               int output_rank, int input_rank, void *user_data);</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1"># Open library</span>
<span class="n">lib</span> <span class="o">=</span> <span class="n">ffi</span><span class="o">.</span><span class="n">dlopen</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s2">&quot;example.so&quot;</span><span class="p">))</span>

<span class="c1"># Do the function call</span>
<span class="n">user_data</span> <span class="o">=</span> <span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;double *&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">callback</span> <span class="o">=</span> <span class="n">LowLevelCallable</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">_transform</span><span class="p">,</span> <span class="n">user_data</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
</pre></div>
</div>
<p>You can find more information in the <a class="reference external" href="https://cffi.readthedocs.io/">cffi</a> documentation.</p>
<p class="rubric">ctypes</p>
<p>With <em>ctypes</em>, the C code and the compilation of the so/DLL is as for
cffi above.  The Python code is different:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># script.py</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">LowLevelCallable</span>

<span class="n">lib</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;example.so&#39;</span><span class="p">))</span>

<span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">user_data</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">user_data</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span>

<span class="c1"># Ctypes has no built-in intptr type, so override the signature</span>
<span class="c1"># instead of trying to get it via ctypes</span>
<span class="n">callback</span> <span class="o">=</span> <span class="n">LowLevelCallable</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">_transform</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span>
    <span class="s2">&quot;int _transform(intptr_t *, double *, int, int, void *)&quot;</span><span class="p">)</span>

<span class="c1"># Perform the call</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
</pre></div>
</div>
<p>You can find more information in the <a class="reference external" href="https://docs.python.org/3/library/ctypes.html">ctypes</a> documentation.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>M. Unser, “Splines: A Perfect Fit for Signal and Image
Processing,” IEEE Signal Processing Magazine, vol. 16, no. 6, pp.
22-38, November 1999.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id4">2</a></span></dt>
<dd><p>G. Borgefors, “Distance transformations in arbitrary
dimensions.”, Computer Vision, Graphics, and Image Processing,
27:321-345, 1984.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>C. R. Maurer, Jr., R. Qi, and V. Raghavan, “A linear time
algorithm for computing exact euclidean distance transforms of
binary images in arbitrary dimensions.” IEEE Trans. PAMI 25,
265-270, 2003.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>A. X. Falcão, J. Stolfi, and R. A. Lotufo. “The image foresting
transform: Theory, algorithms, and applications.” IEEE Trans.
PAMI 26, 19-29. 2004.</p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id2">5</a></span></dt>
<dd><p>T. Briand and P. Monasse, “Theory and Practice of Image B-Spline
Interpolation”, Image Processing On Line, 8, pp. 99–141, 2018.
<a class="reference external" href="https://doi.org/10.5201/ipol.2018.221">https://doi.org/10.5201/ipol.2018.221</a></p>
</dd>
</dl>
</section>
</section>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="stats/continuous_wrapcauchy.html" title="previous page">Wrapped Cauchy Distribution</a>
    <a class='right-next' id="next-link" href="io.html" title="next page">File IO (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.io</span></code>)</a>

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2008-2021, The SciPy community.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.2.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>